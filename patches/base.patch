From 85942a48f11006a85984c8db68bc2bbacdce3de2 Mon Sep 17 00:00:00 2001
From: SamarV-121 <samarvispute121@gmail.com>
Date: Sun, 30 Oct 2016 07:32:12 +0000
Subject: [PATCH] Framework_base MTK patch

Change-Id: I18ed9392ccae7e08f0383655782b7cbc24792bc6
---
 1.patch                                            | 178 +++++
 2.patch                                            | 844 +++++++++++++++++++++
 3.patch                                            |  85 +++
 4.patch                                            |  50 ++
 5.patch                                            | 408 ++++++++++
 6.patch                                            |  56 ++
 api/current.txt                                    |   1 +
 api/system-current.txt                             |   1 +
 .../hardware/camera2/legacy/PerfMeasurement.java   | 308 --------
 .../camera2/legacy/SurfaceTextureRenderer.java     |  82 --
 core/jni/Android.mk                                |   1 -
 core/jni/AndroidRuntime.cpp                        |   2 -
 ...oid_hardware_camera2_legacy_PerfMeasurement.cpp | 335 --------
 libs/hwui/Caches.cpp                               |  13 +-
 libs/hwui/Properties.cpp                           |   2 +-
 libs/hwui/renderthread/EglManager.cpp              |  24 -
 location/java/android/location/GpsStatus.java      |  35 +
 .../java/android/location/IGpsStatusListener.aidl  |   9 +-
 .../java/android/location/LocationManager.java     |  25 +
 media/java/android/media/MediaPlayer.java          |   3 +
 media/jni/android_media_ImageReader.cpp            |  40 +-
 media/jni/android_media_ImageWriter.cpp            |   2 +-
 .../statusbar/policy/MobileSignalController.java   |  18 +-
 .../server/location/GpsLocationProvider.java       |  87 ++-
 .../server/location/GpsStatusListenerHelper.java   |  26 +
 ...android_server_location_GpsLocationProvider.cpp |  62 +-
 26 files changed, 1900 insertions(+), 797 deletions(-)
 create mode 100644 1.patch
 create mode 100644 2.patch
 create mode 100644 3.patch
 create mode 100644 4.patch
 create mode 100644 5.patch
 create mode 100644 6.patch
 delete mode 100644 core/java/android/hardware/camera2/legacy/PerfMeasurement.java
 delete mode 100644 core/jni/android_hardware_camera2_legacy_PerfMeasurement.cpp

diff --git a/1.patch b/1.patch
new file mode 100644
index 0000000..3360685
--- /dev/null
+++ b/1.patch
@@ -0,0 +1,178 @@
+From a98a986bafd21b7ecdeceb224c04711d70133a21 Mon Sep 17 00:00:00 2001
+From: fire855 <thefire855@gmail.com>
+Date: Thu, 14 Apr 2016 15:04:20 +0200
+Subject: [PATCH] Compiling fixes
+
+Change-Id: I17ddadfce34457f56150e975eb5fdad434b61acc
+---
+ media/jni/android_media_ImageReader.cpp | 40 ++++++++++++++++-----------------
+ media/jni/android_media_ImageWriter.cpp |  2 +-
+ 2 files changed, 21 insertions(+), 21 deletions(-)
+
+diff --git a/media/jni/android_media_ImageReader.cpp b/media/jni/android_media_ImageReader.cpp
+index 0034b07..6c8463c 100644
+--- a/media/jni/android_media_ImageReader.cpp
++++ b/media/jni/android_media_ImageReader.cpp
+@@ -92,8 +92,8 @@ class JNIImageReaderContext : public ConsumerBase::FrameAvailableListener
+     CpuConsumer::LockedBuffer* getLockedBuffer();
+     void returnLockedBuffer(CpuConsumer::LockedBuffer* buffer);
+ 
+-    BufferItem* getOpaqueBuffer();
+-    void returnOpaqueBuffer(BufferItem* buffer);
++    BufferQueue::BufferItem* getOpaqueBuffer();
++    void returnOpaqueBuffer(BufferQueue::BufferItem* buffer);
+ 
+     void setCpuConsumer(const sp<CpuConsumer>& consumer) { mConsumer = consumer; }
+     CpuConsumer* getCpuConsumer() { return mConsumer.get(); }
+@@ -123,7 +123,7 @@ class JNIImageReaderContext : public ConsumerBase::FrameAvailableListener
+     static void detachJNI();
+ 
+     List<CpuConsumer::LockedBuffer*> mBuffers;
+-    List<BufferItem*> mOpaqueBuffers;
++    List<BufferQueue::BufferItem*> mOpaqueBuffers;
+     sp<CpuConsumer> mConsumer;
+     sp<BufferItemConsumer> mOpaqueConsumer;
+     sp<IGraphicBufferProducer> mProducer;
+@@ -141,7 +141,7 @@ JNIImageReaderContext::JNIImageReaderContext(JNIEnv* env,
+     mClazz((jclass)env->NewGlobalRef(clazz)) {
+     for (int i = 0; i < maxImages; i++) {
+         CpuConsumer::LockedBuffer *buffer = new CpuConsumer::LockedBuffer;
+-        BufferItem* opaqueBuffer = new BufferItem;
++        BufferQueue::BufferItem* opaqueBuffer = new BufferQueue::BufferItem;
+         mBuffers.push_back(buffer);
+         mOpaqueBuffers.push_back(opaqueBuffer);
+     }
+@@ -187,18 +187,18 @@ void JNIImageReaderContext::returnLockedBuffer(CpuConsumer::LockedBuffer* buffer
+     mBuffers.push_back(buffer);
+ }
+ 
+-BufferItem* JNIImageReaderContext::getOpaqueBuffer() {
++BufferQueue::BufferItem* JNIImageReaderContext::getOpaqueBuffer() {
+     if (mOpaqueBuffers.empty()) {
+         return NULL;
+     }
+     // Return an opaque buffer pointer and remove it from the list
+-    List<BufferItem*>::iterator it = mOpaqueBuffers.begin();
+-    BufferItem* buffer = *it;
++    List<BufferQueue::BufferItem*>::iterator it = mOpaqueBuffers.begin();
++    BufferQueue::BufferItem* buffer = *it;
+     mOpaqueBuffers.erase(it);
+     return buffer;
+ }
+ 
+-void JNIImageReaderContext::returnOpaqueBuffer(BufferItem* buffer) {
++void JNIImageReaderContext::returnOpaqueBuffer(BufferQueue::BufferItem* buffer) {
+     mOpaqueBuffers.push_back(buffer);
+ }
+ 
+@@ -222,7 +222,7 @@ JNIImageReaderContext::~JNIImageReaderContext() {
+     }
+ 
+     // Delete opaque buffers
+-    for (List<BufferItem *>::iterator it = mOpaqueBuffers.begin();
++    for (List<BufferQueue::BufferItem *>::iterator it = mOpaqueBuffers.begin();
+             it != mOpaqueBuffers.end(); it++) {
+         delete *it;
+     }
+@@ -326,7 +326,7 @@ static void Image_setBuffer(JNIEnv* env, jobject thiz,
+ }
+ 
+ static void Image_setOpaqueBuffer(JNIEnv* env, jobject thiz,
+-        const BufferItem* buffer)
++        const BufferQueue::BufferItem* buffer)
+ {
+     env->SetLongField(thiz, gSurfaceImageClassInfo.mNativeBuffer, reinterpret_cast<jlong>(buffer));
+ }
+@@ -716,13 +716,13 @@ static BufferItemConsumer* ImageReader_getOpaqueConsumer(JNIEnv* env, jobject th
+     return ctx->getOpaqueConsumer();
+ }
+ 
+-static BufferItem* Image_getOpaqueBuffer(JNIEnv* env, jobject image)
++static BufferQueue::BufferItem* Image_getOpaqueBuffer(JNIEnv* env, jobject image)
+ {
+-    return reinterpret_cast<BufferItem*>(
++    return reinterpret_cast<BufferQueue::BufferItem*>(
+             env->GetLongField(image, gSurfaceImageClassInfo.mNativeBuffer));
+ }
+ 
+-static int Image_getOpaqueBufferWidth(BufferItem* buffer) {
++static int Image_getOpaqueBufferWidth(BufferQueue::BufferItem* buffer) {
+     if (buffer == NULL) return -1;
+ 
+     if (!buffer->mCrop.isEmpty()) {
+@@ -731,7 +731,7 @@ static int Image_getOpaqueBufferWidth(BufferItem* buffer) {
+     return buffer->mGraphicBuffer->getWidth();
+ }
+ 
+-static int Image_getOpaqueBufferHeight(BufferItem* buffer) {
++static int Image_getOpaqueBufferHeight(BufferQueue::BufferItem* buffer) {
+     if (buffer == NULL) return -1;
+ 
+     if (!buffer->mCrop.isEmpty()) {
+@@ -924,7 +924,7 @@ static void ImageReader_imageRelease(JNIEnv* env, jobject thiz, jobject image)
+ 
+     if (ctx->isOpaque()) {
+         BufferItemConsumer* opaqueConsumer = ctx->getOpaqueConsumer();
+-        BufferItem* opaqueBuffer = Image_getOpaqueBuffer(env, image);
++        BufferQueue::BufferItem* opaqueBuffer = Image_getOpaqueBuffer(env, image);
+         opaqueConsumer->releaseBuffer(*opaqueBuffer); // Not using fence for now.
+         Image_setOpaqueBuffer(env, image, NULL);
+         ctx->returnOpaqueBuffer(opaqueBuffer);
+@@ -951,7 +951,7 @@ static jint ImageReader_opaqueImageSetup(JNIEnv* env, JNIImageReaderContext* ctx
+     }
+ 
+     BufferItemConsumer* opaqueConsumer = ctx->getOpaqueConsumer();
+-    BufferItem* buffer = ctx->getOpaqueBuffer();
++    BufferQueue::BufferItem* buffer = ctx->getOpaqueBuffer();
+     if (buffer == NULL) {
+         ALOGW("Unable to acquire a buffer item, very likely client tried to acquire more than"
+             " maxImages buffers");
+@@ -1106,7 +1106,7 @@ static jint ImageReader_detachImage(JNIEnv* env, jobject thiz, jobject image) {
+     }
+ 
+     BufferItemConsumer* opaqueConsumer = ctx->getOpaqueConsumer();
+-    BufferItem* opaqueBuffer = Image_getOpaqueBuffer(env, image);
++    BufferQueue::BufferItem* opaqueBuffer = Image_getOpaqueBuffer(env, image);
+     if (!opaqueBuffer) {
+         ALOGE(
+                 "Opaque Image already released and can not be detached from ImageReader!!!");
+@@ -1115,7 +1115,7 @@ static jint ImageReader_detachImage(JNIEnv* env, jobject thiz, jobject image) {
+         return -1;
+     }
+ 
+-    res = opaqueConsumer->detachBuffer(opaqueBuffer->mSlot);
++    res = opaqueConsumer->detachBuffer(opaqueBuffer->mBuf);
+     if (res != OK) {
+         ALOGE("Opaque Image detach failed: %s (%d)!!!", strerror(-res), res);
+         jniThrowRuntimeException(env,
+@@ -1214,7 +1214,7 @@ static jobject Image_getByteBuffer(JNIEnv* env, jobject thiz, int idx, int reade
+ static jint Image_getWidth(JNIEnv* env, jobject thiz, jint format)
+ {
+     if (isFormatOpaque(format)) {
+-        BufferItem* opaqueBuffer = Image_getOpaqueBuffer(env, thiz);
++        BufferQueue::BufferItem* opaqueBuffer = Image_getOpaqueBuffer(env, thiz);
+         return Image_getOpaqueBufferWidth(opaqueBuffer);
+     } else {
+         CpuConsumer::LockedBuffer* buffer = Image_getLockedBuffer(env, thiz);
+@@ -1225,7 +1225,7 @@ static jint Image_getWidth(JNIEnv* env, jobject thiz, jint format)
+ static jint Image_getHeight(JNIEnv* env, jobject thiz, jint format)
+ {
+     if (isFormatOpaque(format)) {
+-        BufferItem* opaqueBuffer = Image_getOpaqueBuffer(env, thiz);
++        BufferQueue::BufferItem* opaqueBuffer = Image_getOpaqueBuffer(env, thiz);
+         return Image_getOpaqueBufferHeight(opaqueBuffer);
+     } else {
+         CpuConsumer::LockedBuffer* buffer = Image_getLockedBuffer(env, thiz);
+diff --git a/media/jni/android_media_ImageWriter.cpp b/media/jni/android_media_ImageWriter.cpp
+index f92a8ef..65f8e84 100644
+--- a/media/jni/android_media_ImageWriter.cpp
++++ b/media/jni/android_media_ImageWriter.cpp
+@@ -520,7 +520,7 @@ static jint ImageWriter_attachAndQueueImage(JNIEnv* env, jobject thiz, jlong nat
+ 
+     // Image is guaranteed to be from ImageReader at this point, so it is safe to
+     // cast to BufferItem pointer.
+-    BufferItem* opaqueBuffer = reinterpret_cast<BufferItem*>(nativeBuffer);
++    BufferQueue::BufferItem* opaqueBuffer = reinterpret_cast<BufferQueue::BufferItem*>(nativeBuffer);
+     if (opaqueBuffer == NULL) {
+         jniThrowException(env, "java/lang/IllegalStateException",
+                 "Image is not initialized or already closed");
diff --git a/2.patch b/2.patch
new file mode 100644
index 0000000..79009ff
--- /dev/null
+++ b/2.patch
@@ -0,0 +1,844 @@
+From 336d2ca9e6bbb8f5c1b79c54236fb00859b4fd00 Mon Sep 17 00:00:00 2001
+From: fire855 <thefire855@gmail.com>
+Date: Wed, 13 Apr 2016 16:41:17 +0200
+Subject: [PATCH] Remove PerfMeasurement
+
+Change-Id: I9b11769821867abf0774aaa73f752a3d119c8498
+---
+ .../hardware/camera2/legacy/PerfMeasurement.java   | 308 -------------------
+ .../camera2/legacy/SurfaceTextureRenderer.java     |  82 -----
+ core/jni/Android.mk                                |   1 -
+ core/jni/AndroidRuntime.cpp                        |   2 -
+ ...oid_hardware_camera2_legacy_PerfMeasurement.cpp | 335 ---------------------
+ 5 files changed, 728 deletions(-)
+ delete mode 100644 core/java/android/hardware/camera2/legacy/PerfMeasurement.java
+ delete mode 100644 core/jni/android_hardware_camera2_legacy_PerfMeasurement.cpp
+
+diff --git a/core/java/android/hardware/camera2/legacy/PerfMeasurement.java b/core/java/android/hardware/camera2/legacy/PerfMeasurement.java
+deleted file mode 100644
+index 53278c7..0000000
+--- a/core/java/android/hardware/camera2/legacy/PerfMeasurement.java
++++ /dev/null
+@@ -1,308 +0,0 @@
+-/*
+- * Copyright (C) 2014 The Android Open Source Project
+- *
+- * Licensed under the Apache License, Version 2.0 (the "License");
+- * you may not use this file except in compliance with the License.
+- * You may obtain a copy of the License at
+- *
+- *      http://www.apache.org/licenses/LICENSE-2.0
+- *
+- * Unless required by applicable law or agreed to in writing, software
+- * distributed under the License is distributed on an "AS IS" BASIS,
+- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+- * See the License for the specific language governing permissions and
+- * limitations under the License.
+- */
+-
+-package android.hardware.camera2.legacy;
+-
+-import android.os.SystemClock;
+-import android.util.Log;
+-
+-import java.io.BufferedWriter;
+-import java.io.FileWriter;
+-import java.io.IOException;
+-import java.util.ArrayList;
+-import java.util.LinkedList;
+-import java.util.Queue;
+-
+-/**
+- * GPU and CPU performance measurement for the legacy implementation.
+- *
+- * <p>Measures CPU and GPU processing duration for a set of operations, and dumps
+- * the results into a file.</p>
+- *
+- * <p>Rough usage:
+- * <pre>
+- * {@code
+- *   <set up workload>
+- *   <start long-running workload>
+- *   mPerfMeasurement.startTimer();
+- *   ...render a frame...
+- *   mPerfMeasurement.stopTimer();
+- *   <end workload>
+- *   mPerfMeasurement.dumpPerformanceData("/sdcard/my_data.txt");
+- * }
+- * </pre>
+- * </p>
+- *
+- * <p>All calls to this object must be made within the same thread, and the same GL context.
+- * PerfMeasurement cannot be used outside of a GL context.  The only exception is
+- * dumpPerformanceData, which can be called outside of a valid GL context.</p>
+- */
+-class PerfMeasurement {
+-    private static final String TAG = "PerfMeasurement";
+-
+-    public static final int DEFAULT_MAX_QUERIES = 3;
+-
+-    private final long mNativeContext;
+-
+-    private int mCompletedQueryCount = 0;
+-
+-    /**
+-     * Values for completed measurements
+-     */
+-    private ArrayList<Long> mCollectedGpuDurations = new ArrayList<>();
+-    private ArrayList<Long> mCollectedCpuDurations = new ArrayList<>();
+-    private ArrayList<Long> mCollectedTimestamps = new ArrayList<>();
+-
+-    /**
+-     * Values for in-progress measurements (waiting for async GPU results)
+-     */
+-    private Queue<Long> mTimestampQueue = new LinkedList<>();
+-    private Queue<Long> mCpuDurationsQueue = new LinkedList<>();
+-
+-    private long mStartTimeNs;
+-
+-    /**
+-     * The value returned by {@link #nativeGetNextGlDuration} if no new timing
+-     * measurement is available since the last call.
+-     */
+-    private static final long NO_DURATION_YET = -1l;
+-
+-    /**
+-     * The value returned by {@link #nativeGetNextGlDuration} if timing failed for
+-     * the next timing interval
+-     */
+-    private static final long FAILED_TIMING = -2l;
+-
+-    /**
+-     * Create a performance measurement object with a maximum of {@value #DEFAULT_MAX_QUERIES}
+-     * in-progess queries.
+-     */
+-    public PerfMeasurement() {
+-        mNativeContext = nativeCreateContext(DEFAULT_MAX_QUERIES);
+-    }
+-
+-    /**
+-     * Create a performance measurement object with maxQueries as the maximum number of
+-     * in-progress queries.
+-     *
+-     * @param maxQueries maximum in-progress queries, must be larger than 0.
+-     * @throws IllegalArgumentException if maxQueries is less than 1.
+-     */
+-    public PerfMeasurement(int maxQueries) {
+-        if (maxQueries < 1) throw new IllegalArgumentException("maxQueries is less than 1");
+-        mNativeContext = nativeCreateContext(maxQueries);
+-    }
+-
+-    /**
+-     * Returns true if the Gl timing methods will work, false otherwise.
+-     *
+-     * <p>Must be called within a valid GL context.</p>
+-     */
+-    public static boolean isGlTimingSupported() {
+-        return nativeQuerySupport();
+-    }
+-
+-    /**
+-     * Dump collected data to file, and clear the stored data.
+-     *
+-     * <p>
+-     * Format is a simple csv-like text file with a header,
+-     * followed by a 3-column list of values in nanoseconds:
+-     * <pre>
+-     *   timestamp gpu_duration cpu_duration
+-     *   <long> <long> <long>
+-     *   <long> <long> <long>
+-     *   <long> <long> <long>
+-     *   ....
+-     * </pre>
+-     * </p>
+-     */
+-    public void dumpPerformanceData(String path) {
+-        try (BufferedWriter dump = new BufferedWriter(new FileWriter(path))) {
+-            dump.write("timestamp gpu_duration cpu_duration\n");
+-            for (int i = 0; i < mCollectedGpuDurations.size(); i++) {
+-                dump.write(String.format("%d %d %d\n",
+-                                mCollectedTimestamps.get(i),
+-                                mCollectedGpuDurations.get(i),
+-                                mCollectedCpuDurations.get(i)));
+-            }
+-            mCollectedTimestamps.clear();
+-            mCollectedGpuDurations.clear();
+-            mCollectedCpuDurations.clear();
+-        } catch (IOException e) {
+-            Log.e(TAG, "Error writing data dump to " + path + ":" + e);
+-        }
+-    }
+-
+-    /**
+-     * Start a GPU/CPU timing measurement.
+-     *
+-     * <p>Call before starting a rendering pass. Only one timing measurement can be active at once,
+-     * so {@link #stopTimer} must be called before the next call to this method.</p>
+-     *
+-     * @throws IllegalStateException if the maximum number of queries are in progress already,
+-     *                               or the method is called multiple times in a row, or there is
+-     *                               a GPU error.
+-     */
+-    public void startTimer() {
+-        nativeStartGlTimer(mNativeContext);
+-        mStartTimeNs = SystemClock.elapsedRealtimeNanos();
+-    }
+-
+-    /**
+-     * Finish a GPU/CPU timing measurement.
+-     *
+-     * <p>Call after finishing all the drawing for a rendering pass. Only one timing measurement can
+-     * be active at once, so {@link #startTimer} must be called before the next call to this
+-     * method.</p>
+-     *
+-     * @throws IllegalStateException if no GL timer is currently started, or there is a GPU
+-     *                               error.
+-     */
+-    public void stopTimer() {
+-        // Complete CPU timing
+-        long endTimeNs = SystemClock.elapsedRealtimeNanos();
+-        mCpuDurationsQueue.add(endTimeNs - mStartTimeNs);
+-        // Complete GL timing
+-        nativeStopGlTimer(mNativeContext);
+-
+-        // Poll to see if GL timing results have arrived; if so
+-        // store the results for a frame
+-        long duration = getNextGlDuration();
+-        if (duration > 0) {
+-            mCollectedGpuDurations.add(duration);
+-            mCollectedTimestamps.add(mTimestampQueue.isEmpty() ?
+-                    NO_DURATION_YET : mTimestampQueue.poll());
+-            mCollectedCpuDurations.add(mCpuDurationsQueue.isEmpty() ?
+-                    NO_DURATION_YET : mCpuDurationsQueue.poll());
+-        }
+-        if (duration == FAILED_TIMING) {
+-            // Discard timestamp and CPU measurement since GPU measurement failed
+-            if (!mTimestampQueue.isEmpty()) {
+-                mTimestampQueue.poll();
+-            }
+-            if (!mCpuDurationsQueue.isEmpty()) {
+-                mCpuDurationsQueue.poll();
+-            }
+-        }
+-    }
+-
+-    /**
+-     * Add a timestamp to a timing measurement. These are queued up and matched to completed
+-     * workload measurements as they become available.
+-     */
+-    public void addTimestamp(long timestamp) {
+-        mTimestampQueue.add(timestamp);
+-    }
+-
+-    /**
+-     * Get the next available GPU timing measurement.
+-     *
+-     * <p>Since the GPU works asynchronously, the results of a single start/stopGlTimer measurement
+-     * will only be available some time after the {@link #stopTimer} call is made. Poll this method
+-     * until the result becomes available. If multiple start/endTimer measurements are made in a
+-     * row, the results will be available in FIFO order.</p>
+-     *
+-     * @return The measured duration of the GPU workload for the next pending query, or
+-     *         {@link #NO_DURATION_YET} if no queries are pending or the next pending query has not
+-     *         yet finished, or {@link #FAILED_TIMING} if the GPU was unable to complete the
+-     *         measurement.
+-     *
+-     * @throws IllegalStateException If there is a GPU error.
+-     *
+-     */
+-    private long getNextGlDuration() {
+-        long duration = nativeGetNextGlDuration(mNativeContext);
+-        if (duration > 0) {
+-            mCompletedQueryCount++;
+-        }
+-        return duration;
+-    }
+-
+-    /**
+-     * Returns the number of measurements so far that returned a valid duration
+-     * measurement.
+-     */
+-    public int getCompletedQueryCount() {
+-        return mCompletedQueryCount;
+-    }
+-
+-    @Override
+-    protected void finalize() {
+-        nativeDeleteContext(mNativeContext);
+-    }
+-
+-    /**
+-     * Create a native performance measurement context.
+-     *
+-     * @param maxQueryCount maximum in-progress queries; must be >= 1.
+-     */
+-    private static native long nativeCreateContext(int maxQueryCount);
+-
+-    /**
+-     * Delete the native context.
+-     *
+-     * <p>Not safe to call more than once.</p>
+-     */
+-    private static native void nativeDeleteContext(long contextHandle);
+-
+-    /**
+-     * Query whether the relevant Gl extensions are available for Gl timing
+-     */
+-    private static native boolean nativeQuerySupport();
+-
+-    /**
+-     * Start a GL timing section.
+-     *
+-     * <p>All GL commands between this method and the next {@link #nativeEndGlTimer} will be
+-     * included in the timing.</p>
+-     *
+-     * <p>Must be called from the same thread as calls to {@link #nativeEndGlTimer} and
+-     * {@link #nativeGetNextGlDuration}.</p>
+-     *
+-     * @throws IllegalStateException if a GL error occurs or start is called repeatedly.
+-     */
+-    protected static native void nativeStartGlTimer(long contextHandle);
+-
+-    /**
+-     * Finish a GL timing section.
+-     *
+-     * <p>Some time after this call returns, the time the GPU took to
+-     * execute all work submitted between the latest {@link #nativeStartGlTimer} and
+-     * this call, will become available from calling {@link #nativeGetNextGlDuration}.</p>
+-     *
+-     * <p>Must be called from the same thread as calls to {@link #nativeStartGlTimer} and
+-     * {@link #nativeGetNextGlDuration}.</p>
+-     *
+-     * @throws IllegalStateException if a GL error occurs or stop is called before start
+-     */
+-    protected static native void nativeStopGlTimer(long contextHandle);
+-
+-    /**
+-     * Get the next available GL duration measurement, in nanoseconds.
+-     *
+-     * <p>Must be called from the same thread as calls to {@link #nativeStartGlTimer} and
+-     * {@link #nativeEndGlTimer}.</p>
+-     *
+-     * @return the next GL duration measurement, or {@link #NO_DURATION_YET} if
+-     *         no new measurement is available, or {@link #FAILED_TIMING} if timing
+-     *         failed for the next duration measurement.
+-     * @throws IllegalStateException if a GL error occurs
+-     */
+-    protected static native long nativeGetNextGlDuration(long contextHandle);
+-
+-
+-}
+diff --git a/core/java/android/hardware/camera2/legacy/SurfaceTextureRenderer.java b/core/java/android/hardware/camera2/legacy/SurfaceTextureRenderer.java
+index 86eb01d..10d545a 100644
+--- a/core/java/android/hardware/camera2/legacy/SurfaceTextureRenderer.java
++++ b/core/java/android/hardware/camera2/legacy/SurfaceTextureRenderer.java
+@@ -171,9 +171,6 @@
+     private int maPositionHandle;
+     private int maTextureHandle;
+ 
+-    private PerfMeasurement mPerfMeasurer = null;
+-    private static final String LEGACY_PERF_PROPERTY = "persist.camera.legacy_perf";
+-
+     public SurfaceTextureRenderer(int facing) {
+         mFacing = facing;
+ 
+@@ -501,7 +498,6 @@ private void releaseEGLContext() {
+         if (mEGLDisplay != EGL14.EGL_NO_DISPLAY) {
+             EGL14.eglMakeCurrent(mEGLDisplay, EGL14.EGL_NO_SURFACE, EGL14.EGL_NO_SURFACE,
+                     EGL14.EGL_NO_CONTEXT);
+-            dumpGlTiming();
+             if (mSurfaces != null) {
+                 for (EGLSurfaceHolder holder : mSurfaces) {
+                     if (holder.eglSurface != null) {
+@@ -553,65 +549,6 @@ private void checkGlError(String msg) {
+     }
+ 
+     /**
+-     * Save a measurement dump to disk, in
+-     * {@code /sdcard/CameraLegacy/durations_<time>_<width1>x<height1>_...txt}
+-     */
+-    private void dumpGlTiming() {
+-        if (mPerfMeasurer == null) return;
+-
+-        File legacyStorageDir = new File(Environment.getExternalStorageDirectory(), "CameraLegacy");
+-        if (!legacyStorageDir.exists()){
+-            if (!legacyStorageDir.mkdirs()){
+-                Log.e(TAG, "Failed to create directory for data dump");
+-                return;
+-            }
+-        }
+-
+-        StringBuilder path = new StringBuilder(legacyStorageDir.getPath());
+-        path.append(File.separator);
+-        path.append("durations_");
+-
+-        Time now = new Time();
+-        now.setToNow();
+-        path.append(now.format2445());
+-        path.append("_S");
+-        for (EGLSurfaceHolder surface : mSurfaces) {
+-            path.append(String.format("_%d_%d", surface.width, surface.height));
+-        }
+-        path.append("_C");
+-        for (EGLSurfaceHolder surface : mConversionSurfaces) {
+-            path.append(String.format("_%d_%d", surface.width, surface.height));
+-        }
+-        path.append(".txt");
+-        mPerfMeasurer.dumpPerformanceData(path.toString());
+-    }
+-
+-    private void setupGlTiming() {
+-        if (PerfMeasurement.isGlTimingSupported()) {
+-            Log.d(TAG, "Enabling GL performance measurement");
+-            mPerfMeasurer = new PerfMeasurement();
+-        } else {
+-            Log.d(TAG, "GL performance measurement not supported on this device");
+-            mPerfMeasurer = null;
+-        }
+-    }
+-
+-    private void beginGlTiming() {
+-        if (mPerfMeasurer == null) return;
+-        mPerfMeasurer.startTimer();
+-    }
+-
+-    private void addGlTimestamp(long timestamp) {
+-        if (mPerfMeasurer == null) return;
+-        mPerfMeasurer.addTimestamp(timestamp);
+-    }
+-
+-    private void endGlTiming() {
+-        if (mPerfMeasurer == null) return;
+-        mPerfMeasurer.stopTimer();
+-    }
+-
+-    /**
+      * Return the surface texture to draw to - this is the texture use to when producing output
+      * surface buffers.
+      *
+@@ -669,11 +606,6 @@ public void configureSurfaces(Collection<Pair<Surface, Size>> surfaces) {
+                 mConversionSurfaces.get(0).eglSurface);
+         initializeGLState();
+         mSurfaceTexture = new SurfaceTexture(getTextureId());
+-
+-        // Set up performance tracking if enabled
+-        if (SystemProperties.getBoolean(LEGACY_PERF_PROPERTY, false)) {
+-            setupGlTiming();
+-        }
+     }
+ 
+     /**
+@@ -698,10 +630,6 @@ public void drawIntoSurfaces(CaptureCollector targetCollector) {
+         boolean doTiming = targetCollector.hasPendingPreviewCaptures();
+         checkGlError("before updateTexImage");
+ 
+-        if (doTiming) {
+-            beginGlTiming();
+-        }
+-
+         mSurfaceTexture.updateTexImage();
+ 
+         long timestamp = mSurfaceTexture.getTimestamp();
+@@ -713,18 +641,12 @@ public void drawIntoSurfaces(CaptureCollector targetCollector) {
+             if (DEBUG) {
+                 Log.d(TAG, "Dropping preview frame.");
+             }
+-            if (doTiming) {
+-                endGlTiming();
+-            }
+             return;
+         }
+ 
+         RequestHolder request = captureHolder.first;
+ 
+         Collection<Surface> targetSurfaces = request.getHolderTargets();
+-        if (doTiming) {
+-            addGlTimestamp(timestamp);
+-        }
+ 
+         List<Long> targetSurfaceIds = LegacyCameraDevice.getSurfaceIds(targetSurfaces);
+         for (EGLSurfaceHolder holder : mSurfaces) {
+@@ -769,10 +691,6 @@ public void drawIntoSurfaces(CaptureCollector targetCollector) {
+             }
+         }
+         targetCollector.previewProduced();
+-
+-        if (doTiming) {
+-            endGlTiming();
+-        }
+     }
+ 
+     /**
+diff --git a/core/jni/Android.mk b/core/jni/Android.mk
+index 42b10c4..5f19312 100644
+--- a/core/jni/Android.mk
++++ b/core/jni/Android.mk
+@@ -152,7 +152,6 @@ LOCAL_SRC_FILES:= \
+     android_hardware_Camera.cpp \
+     android_hardware_camera2_CameraMetadata.cpp \
+     android_hardware_camera2_legacy_LegacyCameraDevice.cpp \
+-    android_hardware_camera2_legacy_PerfMeasurement.cpp \
+     android_hardware_camera2_DngCreator.cpp \
+     android_hardware_Radio.cpp \
+     android_hardware_SensorManager.cpp \
+diff --git a/core/jni/AndroidRuntime.cpp b/core/jni/AndroidRuntime.cpp
+index 9acdab4..a5f3910 100644
+--- a/core/jni/AndroidRuntime.cpp
++++ b/core/jni/AndroidRuntime.cpp
+@@ -82,7 +82,6 @@ extern int register_android_opengl_jni_GLES31Ext(JNIEnv* env);
+ extern int register_android_hardware_Camera(JNIEnv *env);
+ extern int register_android_hardware_camera2_CameraMetadata(JNIEnv *env);
+ extern int register_android_hardware_camera2_legacy_LegacyCameraDevice(JNIEnv *env);
+-extern int register_android_hardware_camera2_legacy_PerfMeasurement(JNIEnv *env);
+ extern int register_android_hardware_camera2_DngCreator(JNIEnv *env);
+ extern int register_android_hardware_Radio(JNIEnv *env);
+ extern int register_android_hardware_SensorManager(JNIEnv *env);
+@@ -1402,7 +1401,6 @@ static const RegJNIRec gRegJNI[] = {
+     REG_JNI(register_android_hardware_Camera),
+     REG_JNI(register_android_hardware_camera2_CameraMetadata),
+     REG_JNI(register_android_hardware_camera2_legacy_LegacyCameraDevice),
+-    REG_JNI(register_android_hardware_camera2_legacy_PerfMeasurement),
+     REG_JNI(register_android_hardware_camera2_DngCreator),
+     REG_JNI(register_android_hardware_Radio),
+     REG_JNI(register_android_hardware_SensorManager),
+diff --git a/core/jni/android_hardware_camera2_legacy_PerfMeasurement.cpp b/core/jni/android_hardware_camera2_legacy_PerfMeasurement.cpp
+deleted file mode 100644
+index 7257597..0000000
+--- a/core/jni/android_hardware_camera2_legacy_PerfMeasurement.cpp
++++ /dev/null
+@@ -1,335 +0,0 @@
+-/*
+- * Copyright (C) 2014 The Android Open Source Project
+- *
+- * Licensed under the Apache License, Version 2.0 (the "License");
+- * you may not use this file except in compliance with the License.
+- * You may obtain a copy of the License at
+- *
+- *      http://www.apache.org/licenses/LICENSE-2.0
+- *
+- * Unless required by applicable law or agreed to in writing, software
+- * distributed under the License is distributed on an "AS IS" BASIS,
+- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+- * See the License for the specific language governing permissions and
+- * limitations under the License.
+- */
+-
+-#define LOG_TAG "Camera2-Legacy-PerfMeasurement-JNI"
+-#include <utils/Log.h>
+-#include <utils/Errors.h>
+-#include <utils/Trace.h>
+-#include <utils/Vector.h>
+-
+-#include "jni.h"
+-#include "JNIHelp.h"
+-#include "core_jni_helpers.h"
+-
+-#include <ui/GraphicBuffer.h>
+-#include <system/window.h>
+-#include <GLES2/gl2.h>
+-#include <GLES2/gl2ext.h>
+-
+-using namespace android;
+-
+-// fully-qualified class name
+-#define PERF_MEASUREMENT_CLASS_NAME "android/hardware/camera2/legacy/PerfMeasurement"
+-
+-/** GL utility methods copied from com_google_android_gles_jni_GLImpl.cpp */
+-
+-// Check if the extension at the head of pExtensions is pExtension. Note that pExtensions is
+-// terminated by either 0 or space, while pExtension is terminated by 0.
+-
+-static bool
+-extensionEqual(const GLubyte* pExtensions, const GLubyte* pExtension) {
+-    while (true) {
+-        char a = *pExtensions++;
+-        char b = *pExtension++;
+-        bool aEnd = a == '\0' || a == ' ';
+-        bool bEnd = b == '\0';
+-        if (aEnd || bEnd) {
+-            return aEnd == bEnd;
+-        }
+-        if (a != b) {
+-            return false;
+-        }
+-    }
+-}
+-
+-static const GLubyte*
+-nextExtension(const GLubyte* pExtensions) {
+-    while (true) {
+-        char a = *pExtensions++;
+-        if (a == '\0') {
+-            return pExtensions-1;
+-        } else if ( a == ' ') {
+-            return pExtensions;
+-        }
+-    }
+-}
+-
+-static bool
+-checkForExtension(const GLubyte* pExtensions, const GLubyte* pExtension) {
+-    for (; *pExtensions != '\0'; pExtensions = nextExtension(pExtensions)) {
+-        if (extensionEqual(pExtensions, pExtension)) {
+-            return true;
+-        }
+-    }
+-    return false;
+-}
+-
+-/** End copied GL utility methods */
+-
+-bool checkGlError(JNIEnv* env) {
+-    int error;
+-    if ((error = glGetError()) != GL_NO_ERROR) {
+-        jniThrowExceptionFmt(env, "java/lang/IllegalStateException",
+-                "GLES20 error: 0x%d", error);
+-        return true;
+-    }
+-    return false;
+-}
+-
+-/**
+- * Asynchronous low-overhead GL performance measurement using
+- * http://www.khronos.org/registry/gles/extensions/EXT/EXT_disjoint_timer_query.txt
+- *
+- * Measures the duration of GPU processing for a set of GL commands, delivering
+- * the measurement asynchronously once processing completes.
+- *
+- * All calls must come from a single thread with a valid GL context active.
+- **/
+-class PerfMeasurementContext {
+-  private:
+-    Vector<GLuint> mTimingQueries;
+-    size_t mTimingStartIndex;
+-    size_t mTimingEndIndex;
+-    size_t mTimingQueryIndex;
+-    size_t mFreeQueries;
+-
+-    bool mInitDone;
+-  public:
+-
+-    /**
+-     * maxQueryCount should be a conservative estimate of how many query objects
+-     * will be active at once, which is a function of the GPU's level of
+-     * pipelining and the frequency of queries.
+-     */
+-    PerfMeasurementContext(size_t maxQueryCount):
+-            mTimingStartIndex(0),
+-            mTimingEndIndex(0),
+-            mTimingQueryIndex(0) {
+-        mTimingQueries.resize(maxQueryCount);
+-        mFreeQueries = maxQueryCount;
+-        mInitDone = false;
+-    }
+-
+-    int getMaxQueryCount() {
+-        return mTimingQueries.size();
+-    }
+-
+-    /**
+-     * Start a measurement period using the next available query object.
+-     * Returns INVALID_OPERATION if called multiple times in a row,
+-     * and BAD_VALUE if no more query objects are available.
+-     */
+-    int startGlTimer() {
+-        // Lazy init of queries to avoid needing GL context during construction
+-        if (!mInitDone) {
+-            glGenQueriesEXT(mTimingQueries.size(), mTimingQueries.editArray());
+-            mInitDone = true;
+-        }
+-
+-        if (mTimingEndIndex != mTimingStartIndex) {
+-            return INVALID_OPERATION;
+-        }
+-
+-        if (mFreeQueries == 0) {
+-            return BAD_VALUE;
+-        }
+-
+-        glBeginQueryEXT(GL_TIME_ELAPSED_EXT, mTimingQueries[mTimingStartIndex]);
+-
+-        mTimingStartIndex = (mTimingStartIndex + 1) % mTimingQueries.size();
+-        mFreeQueries--;
+-
+-        return OK;
+-    }
+-
+-    /**
+-     * Finish the current measurement period
+-     * Returns INVALID_OPERATION if called before any startGLTimer calls
+-     * or if called multiple times in a row.
+-     */
+-    int stopGlTimer() {
+-        size_t nextEndIndex = (mTimingEndIndex + 1) % mTimingQueries.size();
+-        if (nextEndIndex != mTimingStartIndex) {
+-            return INVALID_OPERATION;
+-        }
+-        glEndQueryEXT(GL_TIME_ELAPSED_EXT);
+-
+-        mTimingEndIndex = nextEndIndex;
+-
+-        return OK;
+-    }
+-
+-    static const nsecs_t NO_DURATION_YET = -1L;
+-    static const nsecs_t FAILED_MEASUREMENT = -2L;
+-
+-    /**
+-     * Get the next available duration measurement.
+-     *
+-     * Returns NO_DURATION_YET if no new measurement is available,
+-     * and FAILED_MEASUREMENT if an error occurred during the next
+-     * measurement period.
+-     *
+-     * Otherwise returns a positive number of nanoseconds measuring the
+-     * duration of the oldest completed query.
+-     */
+-    nsecs_t getNextGlDuration() {
+-        if (!mInitDone) {
+-            // No start/stop called yet
+-            return NO_DURATION_YET;
+-        }
+-
+-        GLint available;
+-        glGetQueryObjectivEXT(mTimingQueries[mTimingQueryIndex],
+-                GL_QUERY_RESULT_AVAILABLE_EXT, &available);
+-        if (!available) {
+-            return NO_DURATION_YET;
+-        }
+-
+-        GLint64 duration = FAILED_MEASUREMENT;
+-        GLint disjointOccurred;
+-        glGetIntegerv(GL_GPU_DISJOINT_EXT, &disjointOccurred);
+-
+-        if (!disjointOccurred) {
+-            glGetQueryObjecti64vEXT(mTimingQueries[mTimingQueryIndex],
+-                    GL_QUERY_RESULT_EXT,
+-                    &duration);
+-        }
+-
+-        mTimingQueryIndex = (mTimingQueryIndex + 1) % mTimingQueries.size();
+-        mFreeQueries++;
+-
+-        return static_cast<nsecs_t>(duration);
+-    }
+-
+-    static bool isMeasurementSupported() {
+-        const GLubyte* extensions = glGetString(GL_EXTENSIONS);
+-        return checkForExtension(extensions,
+-                reinterpret_cast<const GLubyte*>("GL_EXT_disjoint_timer_query"));
+-    }
+-
+-};
+-
+-PerfMeasurementContext* getContext(jlong context) {
+-    return reinterpret_cast<PerfMeasurementContext*>(context);
+-}
+-
+-extern "C" {
+-
+-static jlong PerfMeasurement_nativeCreateContext(JNIEnv* env, jobject thiz,
+-        jint maxQueryCount) {
+-    PerfMeasurementContext *context = new PerfMeasurementContext(maxQueryCount);
+-    return reinterpret_cast<jlong>(context);
+-}
+-
+-static void PerfMeasurement_nativeDeleteContext(JNIEnv* env, jobject thiz,
+-        jlong contextHandle) {
+-    PerfMeasurementContext *context = getContext(contextHandle);
+-    delete(context);
+-}
+-
+-static jboolean PerfMeasurement_nativeQuerySupport(JNIEnv* env, jobject thiz) {
+-    bool supported = PerfMeasurementContext::isMeasurementSupported();
+-    checkGlError(env);
+-    return static_cast<jboolean>(supported);
+-}
+-
+-static void PerfMeasurement_nativeStartGlTimer(JNIEnv* env, jobject thiz,
+-        jlong contextHandle) {
+-
+-    PerfMeasurementContext *context = getContext(contextHandle);
+-    status_t err = context->startGlTimer();
+-    if (err != OK) {
+-        switch (err) {
+-            case INVALID_OPERATION:
+-                jniThrowExceptionFmt(env, "java/lang/IllegalStateException",
+-                        "Mismatched start/end GL timing calls");
+-                return;
+-            case BAD_VALUE:
+-                jniThrowExceptionFmt(env, "java/lang/IllegalStateException",
+-                        "Too many timing queries in progress, max %d",
+-                        context->getMaxQueryCount());
+-                return;
+-            default:
+-                jniThrowExceptionFmt(env, "java/lang/IllegalStateException",
+-                        "Unknown error starting GL timing");
+-                return;
+-        }
+-    }
+-    checkGlError(env);
+-}
+-
+-static void PerfMeasurement_nativeStopGlTimer(JNIEnv* env, jobject thiz,
+-            jlong contextHandle) {
+-
+-    PerfMeasurementContext *context = getContext(contextHandle);
+-    status_t err = context->stopGlTimer();
+-    if (err != OK) {
+-        switch (err) {
+-            case INVALID_OPERATION:
+-                jniThrowExceptionFmt(env, "java/lang/IllegalStateException",
+-                        "Mismatched start/end GL timing calls");
+-                return;
+-            default:
+-                jniThrowExceptionFmt(env, "java/lang/IllegalStateException",
+-                        "Unknown error ending GL timing");
+-                return;
+-        }
+-    }
+-    checkGlError(env);
+-}
+-
+-static jlong PerfMeasurement_nativeGetNextGlDuration(JNIEnv* env,
+-        jobject thiz, jlong contextHandle) {
+-    PerfMeasurementContext *context = getContext(contextHandle);
+-    nsecs_t duration = context->getNextGlDuration();
+-
+-    checkGlError(env);
+-    return static_cast<jlong>(duration);
+-}
+-
+-} // extern "C"
+-
+-static JNINativeMethod gPerfMeasurementMethods[] = {
+-    { "nativeCreateContext",
+-      "(I)J",
+-      (jlong *)PerfMeasurement_nativeCreateContext },
+-    { "nativeDeleteContext",
+-      "(J)V",
+-      (void *)PerfMeasurement_nativeDeleteContext },
+-    { "nativeQuerySupport",
+-      "()Z",
+-      (jboolean *)PerfMeasurement_nativeQuerySupport },
+-    { "nativeStartGlTimer",
+-      "(J)V",
+-      (void *)PerfMeasurement_nativeStartGlTimer },
+-    { "nativeStopGlTimer",
+-      "(J)V",
+-      (void *)PerfMeasurement_nativeStopGlTimer },
+-    { "nativeGetNextGlDuration",
+-      "(J)J",
+-      (jlong *)PerfMeasurement_nativeGetNextGlDuration }
+-};
+-
+-
+-// Get all the required offsets in java class and register native functions
+-int register_android_hardware_camera2_legacy_PerfMeasurement(JNIEnv* env)
+-{
+-    // Register native functions
+-    return RegisterMethodsOrDie(env,
+-            PERF_MEASUREMENT_CLASS_NAME,
+-            gPerfMeasurementMethods,
+-            NELEM(gPerfMeasurementMethods));
+-}
diff --git a/3.patch b/3.patch
new file mode 100644
index 0000000..0007da1
--- /dev/null
+++ b/3.patch
@@ -0,0 +1,85 @@
+From 8d301fe7c09f49dce0dea543f58aa5c93794184e Mon Sep 17 00:00:00 2001
+From: fire855 <thefire855@gmail.com>
+Date: Thu, 14 Apr 2016 15:05:18 +0200
+Subject: [PATCH] Fix hwui problems
+
+Change-Id: Ib1130401d0c003f7d6476d638ec7df1cae39f8a1
+---
+ libs/hwui/Caches.cpp                  | 13 +++----------
+ libs/hwui/Properties.cpp              |  2 +-
+ libs/hwui/renderthread/EglManager.cpp | 24 ------------------------
+ 3 files changed, 4 insertions(+), 35 deletions(-)
+
+diff --git a/libs/hwui/Caches.cpp b/libs/hwui/Caches.cpp
+index 2763e89..a324ac3 100644
+--- a/libs/hwui/Caches.cpp
++++ b/libs/hwui/Caches.cpp
+@@ -87,16 +87,9 @@ void Caches::initFont() {
+ }
+ 
+ void Caches::initExtensions() {
+-    if (mExtensions.hasDebugMarker()) {
+-        eventMark = glInsertEventMarkerEXT;
+-
+-        startMark = glPushGroupMarkerEXT;
+-        endMark = glPopGroupMarkerEXT;
+-    } else {
+-        eventMark = eventMarkNull;
+-        startMark = startMarkNull;
+-        endMark = endMarkNull;
+-    }
++    eventMark = eventMarkNull;
++    startMark = startMarkNull;
++    endMark = endMarkNull;
+ }
+ 
+ void Caches::initConstraints() {
+diff --git a/libs/hwui/Properties.cpp b/libs/hwui/Properties.cpp
+index 2e63793..413ebec 100644
+--- a/libs/hwui/Properties.cpp
++++ b/libs/hwui/Properties.cpp
+@@ -29,7 +29,7 @@ bool Properties::debugLayersUpdates = false;
+ bool Properties::debugOverdraw = false;
+ bool Properties::showDirtyRegions = false;
+ bool Properties::skipEmptyFrames = true;
+-bool Properties::swapBuffersWithDamage = true;
++bool Properties::swapBuffersWithDamage = false;
+ 
+ DebugLevel Properties::debugLevel = kDebugDisabled;
+ OverdrawColorSet Properties::overdrawColorSet = OverdrawColorSet::Default;
+diff --git a/libs/hwui/renderthread/EglManager.cpp b/libs/hwui/renderthread/EglManager.cpp
+index eb332d5..a2f7106 100644
+--- a/libs/hwui/renderthread/EglManager.cpp
++++ b/libs/hwui/renderthread/EglManager.cpp
+@@ -261,31 +261,7 @@ bool EglManager::swapBuffers(EGLSurface surface, const SkRect& dirty,
+     }
+ #endif
+ 
+-#ifdef EGL_KHR_swap_buffers_with_damage
+-    if (CC_LIKELY(Properties::swapBuffersWithDamage)) {
+-        SkIRect idirty;
+-        dirty.roundOut(&idirty);
+-        /*
+-         * EGL_KHR_swap_buffers_with_damage spec states:
+-         *
+-         * The rectangles are specified relative to the bottom-left of the surface
+-         * and the x and y components of each rectangle specify the bottom-left
+-         * position of that rectangle.
+-         *
+-         * HWUI does everything with 0,0 being top-left, so need to map
+-         * the rect
+-         */
+-        EGLint y = height - (idirty.y() + idirty.height());
+-        // layout: {x, y, width, height}
+-        EGLint rects[4] = { idirty.x(), y, idirty.width(), idirty.height() };
+-        EGLint numrects = dirty.isEmpty() ? 0 : 1;
+-        eglSwapBuffersWithDamageKHR(mEglDisplay, surface, rects, numrects);
+-    } else {
+-        eglSwapBuffers(mEglDisplay, surface);
+-    }
+-#else
+     eglSwapBuffers(mEglDisplay, surface);
+-#endif
+ 
+     EGLint err = eglGetError();
+     if (CC_LIKELY(err == EGL_SUCCESS)) {
diff --git a/4.patch b/4.patch
new file mode 100644
index 0000000..29cb7be
--- /dev/null
+++ b/4.patch
@@ -0,0 +1,50 @@
+From 65aa2299038fc828b779522b273723cb8b214ca5 Mon Sep 17 00:00:00 2001
+From: fire855 <thefire855@gmail.com>
+Date: Sun, 17 Apr 2016 13:39:34 +0200
+Subject: [PATCH] Add prepareWithoutScan (for FMRadio)
+
+Change-Id: I81fb9ec96597f07310ca89af84ca85d647eecee0
+---
+ api/current.txt                           | 1 +
+ api/system-current.txt                    | 1 +
+ media/java/android/media/MediaPlayer.java | 3 +++
+ 3 files changed, 5 insertions(+)
+
+diff --git a/api/current.txt b/api/current.txt
+index c45cc3d..3b8eaf0 100644
+--- a/api/current.txt
++++ b/api/current.txt
+@@ -16106,6 +16106,7 @@ package android.media {
+     method public boolean isPlaying();
+     method public void pause() throws java.lang.IllegalStateException;
+     method public void prepare() throws java.io.IOException, java.lang.IllegalStateException;
++    method public void prepareWithoutScan() throws java.io.IOException, java.lang.IllegalStateException;
+     method public void prepareAsync() throws java.lang.IllegalStateException;
+     method public void release();
+     method public void reset();
+diff --git a/api/system-current.txt b/api/system-current.txt
+index 1e7b94e..ca53796 100644
+--- a/api/system-current.txt
++++ b/api/system-current.txt
+@@ -17373,6 +17373,7 @@ package android.media {
+     method public boolean isPlaying();
+     method public void pause() throws java.lang.IllegalStateException;
+     method public void prepare() throws java.io.IOException, java.lang.IllegalStateException;
++    method public void prepareWithoutScan() throws java.io.IOException, java.lang.IllegalStateException;
+     method public void prepareAsync() throws java.lang.IllegalStateException;
+     method public void release();
+     method public void reset();
+diff --git a/media/java/android/media/MediaPlayer.java b/media/java/android/media/MediaPlayer.java
+index b3f25ee..3a95717 100644
+--- a/media/java/android/media/MediaPlayer.java
++++ b/media/java/android/media/MediaPlayer.java
+@@ -1158,6 +1158,9 @@ public void prepare() throws IOException, IllegalStateException {
+         _prepare();
+         scanInternalSubtitleTracks();
+     }
++    public void prepareWithoutScan() throws IOException, IllegalStateException {
++        _prepare();
++    }
+ 
+     private native void _prepare() throws IOException, IllegalStateException;
+ 
diff --git a/5.patch b/5.patch
new file mode 100644
index 0000000..f9ce110
--- /dev/null
+++ b/5.patch
@@ -0,0 +1,408 @@
+From bb2e27cfe21cedb9f746df68fb15a3df5fb2b573 Mon Sep 17 00:00:00 2001
+From: fire855 <thefire855@gmail.com>
+Date: Sat, 30 Jul 2016 18:03:14 +0200
+Subject: [PATCH] location: implement mtk GNSS extension
+
+Change-Id: Ib152bfdfa935605e7c7ee1f467504126af277ea7
+---
+ location/java/android/location/GpsStatus.java      | 35 +++++++++
+ .../java/android/location/IGpsStatusListener.aidl  |  9 ++-
+ .../java/android/location/LocationManager.java     | 25 +++++++
+ .../server/location/GpsLocationProvider.java       | 87 ++++++++++++++++++++--
+ .../server/location/GpsStatusListenerHelper.java   | 26 +++++++
+ ...android_server_location_GpsLocationProvider.cpp | 62 ++++++++++++++-
+ 6 files changed, 233 insertions(+), 11 deletions(-)
+
+diff --git a/location/java/android/location/GpsStatus.java b/location/java/android/location/GpsStatus.java
+index 323f326..cd337b6 100644
+--- a/location/java/android/location/GpsStatus.java
++++ b/location/java/android/location/GpsStatus.java
+@@ -168,6 +168,41 @@ synchronized void setStatus(int svCount, int[] prns, float[] snrs,
+     }
+ 
+     /**
++     * Used internally within {@link LocationManager} to copy GPS status
++     * data from the Location Manager Service to its cached GpsStatus instance.
++     * Is synchronized to ensure that GPS status updates are atomic.
++     *
++     * This is modified to become aware of explicit GNSS support of &gt;32
++     * satellites.
++     */
++    synchronized void setStatusFromGnss(int gnssSvCount, int[] prns, float[] snrs,
++            float[] elevations, float[] azimuths,
++            boolean[] ephemerisPresences,
++            boolean[] almanacPresences,
++            boolean[] usedInFix) {
++        clearSatellites();
++        for (int i = 0; i < gnssSvCount; i++) {
++            int prn = prns[i] - 1;
++
++            if (prn >= 0 && prn < NUM_SATELLITES) {
++                GpsSatellite satellite = mSatellites.get(prn);
++                if (satellite == null) {
++                    satellite = new GpsSatellite(prn);
++                    mSatellites.put(prn, satellite);
++                }
++
++                satellite.mValid = true;
++                satellite.mSnr = snrs[i];
++                satellite.mElevation = elevations[i];
++                satellite.mAzimuth = azimuths[i];
++                satellite.mHasEphemeris = ephemerisPresences[i];
++                satellite.mHasAlmanac = almanacPresences[i];
++                satellite.mUsedInFix = usedInFix[i];
++            }
++        }
++    }
++
++    /**
+      * Used by {@link LocationManager#getGpsStatus} to copy LocationManager's
+      * cached GpsStatus instance to the client's copy.
+      * Since this method is only used within {@link LocationManager#getGpsStatus},
+diff --git a/location/java/android/location/IGpsStatusListener.aidl b/location/java/android/location/IGpsStatusListener.aidl
+index 62b1c6b..e45199b 100644
+--- a/location/java/android/location/IGpsStatusListener.aidl
++++ b/location/java/android/location/IGpsStatusListener.aidl
+@@ -26,8 +26,13 @@ oneway interface IGpsStatusListener
+     void onGpsStarted();
+     void onGpsStopped();
+     void onFirstFix(int ttff);
+-    void onSvStatusChanged(int svCount, in int[] prns, in float[] snrs, 
+-            in float[] elevations, in float[] azimuths, 
++    void onSvStatusChanged(int svCount, in int[] prns, in float[] snrs,
++            in float[] elevations, in float[] azimuths,
+             int ephemerisMask, int almanacMask, int usedInFixMask);
++    void onGnssSvStatusChanged(int gnssSvCount, in int[] prns, in float[] snrs,
++            in float[] elevations, in float[] azimuths,
++            in boolean[] ephemerisPresences,
++            in boolean[] almanacPresences,
++            in boolean[] usedInFix);
+     void onNmeaReceived(long timestamp, String nmea);
+ }
+diff --git a/location/java/android/location/LocationManager.java b/location/java/android/location/LocationManager.java
+index 4544814..0086434 100644
+--- a/location/java/android/location/LocationManager.java
++++ b/location/java/android/location/LocationManager.java
+@@ -1479,6 +1479,31 @@ public void onSvStatusChanged(int svCount, int[] prns, float[] snrs,
+         }
+ 
+         @Override
++        public void onGnssSvStatusChanged(int gnssSvCount, int[] prns, float[] snrs,
++                float[] elevations, float[] azimuths,
++                boolean[] ephemerisPresences,
++                boolean[] almanacPresences,
++                boolean[] usedInFix) {
++            if (mListener != null) {
++                mGpsStatus.setStatusFromGnss(
++                        gnssSvCount,
++                        prns,
++                        snrs,
++                        elevations,
++                        azimuths,
++                        ephemerisPresences,
++                        almanacPresences,
++                        usedInFix);
++
++                Message msg = Message.obtain();
++                msg.what = GpsStatus.GPS_EVENT_SATELLITE_STATUS;
++                // remove any SV status messages already in the queue
++                mGpsHandler.removeMessages(GpsStatus.GPS_EVENT_SATELLITE_STATUS);
++                mGpsHandler.sendMessage(msg);
++            }
++        }
++
++        @Override
+         public void onNmeaReceived(long timestamp, String nmea) {
+             if (mNmeaListener != null) {
+                 synchronized (mNmeaBuffer) {
+diff --git a/services/core/java/com/android/server/location/GpsLocationProvider.java b/services/core/java/com/android/server/location/GpsLocationProvider.java
+index bdb77db..140c99c 100644
+--- a/services/core/java/com/android/server/location/GpsLocationProvider.java
++++ b/services/core/java/com/android/server/location/GpsLocationProvider.java
+@@ -1525,6 +1525,72 @@ private void reportSvStatus() {
+     }
+ 
+     /**
++     * Count number of GNSS satellites used in fix.
++     *
++     * We could not rely on Integer.bitCount as GNSS used-in-fix info is not
++     * represented as a bit-mask.
++     */
++    private int countGnssSvUsedInFix(final int gnssSvCount) {
++        int result = 0;
++
++        for (int i = 0; i < gnssSvCount; i++) {
++            if (mSvUsedInFix[i]) {
++                result++;
++            }
++        }
++
++        return result;
++    }
++
++    /**
++     * called from native code to update GNSS SV info
++     */
++    private void reportGnssSvStatus() {
++        final int svCount = native_read_gnss_sv_status(
++                mSvs,
++                mSnrs,
++                mSvElevations,
++                mSvAzimuths,
++                mSvEphemerisPresences,
++                mSvAlmanacPresences,
++                mSvUsedInFix);
++        mListenerHelper.onGnssSvStatusChanged(
++                svCount,
++                mSvs,
++                mSnrs,
++                mSvElevations,
++                mSvAzimuths,
++                mSvEphemerisPresences,
++                mSvAlmanacPresences,
++                mSvUsedInFix);
++
++        if (VERBOSE) {
++            Log.v(TAG, "GNSS SV count: " + svCount);
++            for (int i = 0; i < svCount; i++) {
++                Log.v(TAG, "sv: " + mSvs[i] +
++                        " snr: " + mSnrs[i]/10 +
++                        " elev: " + mSvElevations[i] +
++                        " azimuth: " + mSvAzimuths[i] +
++                        (!mSvEphemerisPresences[i] ? "  " : " E") +
++                        (!mSvAlmanacPresences[i] ? "  " : " A") +
++                        (!mSvUsedInFix[i] ? "" : "U"));
++            }
++        }
++
++        // return number of sets used in fix instead of total
++        updateStatus(mStatus, countGnssSvUsedInFix(svCount));
++
++        if (mNavigating && mStatus == LocationProvider.AVAILABLE && mLastFixTime > 0 &&
++            System.currentTimeMillis() - mLastFixTime > RECENT_FIX_TIMEOUT) {
++            // send an intent to notify that the GPS is no longer receiving fixes.
++            Intent intent = new Intent(LocationManager.GPS_FIX_CHANGE_ACTION);
++            intent.putExtra(LocationManager.EXTRA_GPS_ENABLED, false);
++            mContext.sendBroadcastAsUser(intent, UserHandle.ALL);
++            updateStatus(LocationProvider.TEMPORARILY_UNAVAILABLE, mSvCount);
++        }
++    }
++
++    /**
+      * called from native code to update AGPS status
+      */
+     private void reportAGpsStatus(int type, int status, byte[] ipaddr) {
+@@ -2257,12 +2323,18 @@ public void reset() {
+     private static final int ALMANAC_MASK = 1;
+     private static final int USED_FOR_FIX_MASK = 2;
+ 
++    // GNSS extension
++    private static final int MAX_GNSS_SVS = 256;
++
+     // preallocated arrays, to avoid memory allocation in reportStatus()
+-    private int mSvs[] = new int[MAX_SVS];
+-    private float mSnrs[] = new float[MAX_SVS];
+-    private float mSvElevations[] = new float[MAX_SVS];
+-    private float mSvAzimuths[] = new float[MAX_SVS];
++    private int mSvs[] = new int[MAX_GNSS_SVS];
++    private float mSnrs[] = new float[MAX_GNSS_SVS];
++    private float mSvElevations[] = new float[MAX_GNSS_SVS];
++    private float mSvAzimuths[] = new float[MAX_GNSS_SVS];
+     private int mSvMasks[] = new int[3];
++    private boolean mSvEphemerisPresences[] = new boolean[MAX_GNSS_SVS];
++    private boolean mSvAlmanacPresences[] = new boolean[MAX_GNSS_SVS];
++    private boolean mSvUsedInFix[] = new boolean[MAX_GNSS_SVS];
+     private int mSvCount;
+     // preallocated to avoid memory allocation in reportNmea()
+     private byte[] mNmeaBuffer = new byte[120];
+@@ -2284,6 +2356,12 @@ private native boolean native_set_position_mode(int mode, int recurrence, int mi
+     // mask[0] is ephemeris mask and mask[1] is almanac mask
+     private native int native_read_sv_status(int[] svs, float[] snrs,
+             float[] elevations, float[] azimuths, int[] masks);
++    // returns number of GNSS SVs
++    private native int native_read_gnss_sv_status(int[] svs, float[] snrs,
++            float[] elevations, float[] azimuths,
++            boolean[] ephemerisPresences,
++            boolean[] almanacPresences,
++            boolean[] usedInFix);
+     private native int native_read_nmea(byte[] buffer, int bufferSize);
+     private native void native_inject_location(double latitude, double longitude, float accuracy);
+ 
+@@ -2335,4 +2413,3 @@ private static native boolean native_add_geofence(int geofenceId, double latitud
+     // GNSS Configuration
+     private static native void native_configuration_update(String configData);
+ }
+-
+diff --git a/services/core/java/com/android/server/location/GpsStatusListenerHelper.java b/services/core/java/com/android/server/location/GpsStatusListenerHelper.java
+index 53ff6c2..c49eda0 100644
+--- a/services/core/java/com/android/server/location/GpsStatusListenerHelper.java
++++ b/services/core/java/com/android/server/location/GpsStatusListenerHelper.java
+@@ -98,6 +98,32 @@ public void execute(IGpsStatusListener listener) throws RemoteException {
+         foreach(operation);
+     }
+ 
++    public void onGnssSvStatusChanged(
++            final int svCount,
++            final int[] prns,
++            final float[] snrs,
++            final float[] elevations,
++            final float[] azimuths,
++            final boolean[] ephemerisPresences,
++            final boolean[] almanacPresences,
++            final boolean[] usedInFix) {
++        Operation operation = new Operation() {
++            @Override
++            public void execute(IGpsStatusListener listener) throws RemoteException {
++                listener.onGnssSvStatusChanged(
++                        svCount,
++                        prns,
++                        snrs,
++                        elevations,
++                        azimuths,
++                        ephemerisPresences,
++                        almanacPresences,
++                        usedInFix);
++            }
++        };
++        foreach(operation);
++    }
++
+     public void onNmeaReceived(final long timestamp, final String nmea) {
+         Operation operation = new Operation() {
+             @Override
+diff --git a/services/core/jni/com_android_server_location_GpsLocationProvider.cpp b/services/core/jni/com_android_server_location_GpsLocationProvider.cpp
+index 91eeb8b..292cca9 100644
+--- a/services/core/jni/com_android_server_location_GpsLocationProvider.cpp
++++ b/services/core/jni/com_android_server_location_GpsLocationProvider.cpp
+@@ -21,7 +21,7 @@
+ #include "JNIHelp.h"
+ #include "jni.h"
+ #include "hardware/hardware.h"
+-#include "hardware/gps.h"
++#include "hardware/gps_mtk.h"
+ #include "hardware_legacy/power.h"
+ #include "utils/Log.h"
+ #include "utils/misc.h"
+@@ -39,6 +39,7 @@ static jobject mCallbacksObj = NULL;
+ static jmethodID method_reportLocation;
+ static jmethodID method_reportStatus;
+ static jmethodID method_reportSvStatus;
++static jmethodID method_reportGnssSvStatus;
+ static jmethodID method_reportAGpsStatus;
+ static jmethodID method_reportNmea;
+ static jmethodID method_setEngineCapabilities;
+@@ -69,6 +70,7 @@ static const GnssConfigurationInterface* sGnssConfigurationInterface = NULL;
+ 
+ // temporary storage for GPS callbacks
+ static GpsSvStatus  sGpsSvStatus;
++static GnssSvStatus  sGnssSvStatus;
+ static const char* sNmeaString;
+ static int sNmeaStringLength;
+ 
+@@ -110,6 +112,14 @@ static void sv_status_callback(GpsSvStatus* sv_status)
+     checkAndClearExceptionFromCallback(env, __FUNCTION__);
+ }
+ 
++static void gnss_sv_status_callback(GnssSvStatus* sv_status)
++{
++    JNIEnv* env = AndroidRuntime::getJNIEnv();
++    memcpy(&sGnssSvStatus, sv_status, sizeof(sGnssSvStatus));
++    env->CallVoidMethod(mCallbacksObj, method_reportGnssSvStatus);
++    checkAndClearExceptionFromCallback(env, __FUNCTION__);
++}
++
+ static void nmea_callback(GpsUtcTime timestamp, const char* nmea, int length)
+ {
+     JNIEnv* env = AndroidRuntime::getJNIEnv();
+@@ -151,8 +161,8 @@ static pthread_t create_thread_callback(const char* name, void (*start)(void *),
+     return (pthread_t)AndroidRuntime::createJavaThread(name, start, arg);
+ }
+ 
+-GpsCallbacks sGpsCallbacks = {
+-    sizeof(GpsCallbacks),
++GpsCallbacks_mtk sGpsCallbacks = {
++    sizeof(GpsCallbacks_mtk),
+     location_callback,
+     status_callback,
+     sv_status_callback,
+@@ -162,6 +172,8 @@ GpsCallbacks sGpsCallbacks = {
+     release_wakelock_callback,
+     create_thread_callback,
+     request_utc_time_callback,
++    // MTK
++    gnss_sv_status_callback,
+ };
+ 
+ static void xtra_download_request_callback()
+@@ -446,6 +458,7 @@ static void android_location_GpsLocationProvider_class_init_native(JNIEnv* env,
+     method_reportLocation = env->GetMethodID(clazz, "reportLocation", "(IDDDFFFJ)V");
+     method_reportStatus = env->GetMethodID(clazz, "reportStatus", "(I)V");
+     method_reportSvStatus = env->GetMethodID(clazz, "reportSvStatus", "()V");
++    method_reportGnssSvStatus = env->GetMethodID(clazz, "reportGnssSvStatus", "()V");
+     method_reportAGpsStatus = env->GetMethodID(clazz, "reportAGpsStatus", "(II[B)V");
+     method_reportNmea = env->GetMethodID(clazz, "reportNmea", "(J)V");
+     method_setEngineCapabilities = env->GetMethodID(clazz, "setEngineCapabilities", "(I)V");
+@@ -534,7 +547,7 @@ static jboolean android_location_GpsLocationProvider_init(JNIEnv* env, jobject o
+         mCallbacksObj = env->NewGlobalRef(obj);
+ 
+     // fail if the main interface fails to initialize
+-    if (!sGpsInterface || sGpsInterface->init(&sGpsCallbacks) != 0)
++    if (!sGpsInterface || sGpsInterface->init((GpsCallbacks*)&sGpsCallbacks) != 0)
+         return JNI_FALSE;
+ 
+     // if XTRA initialization fails we will disable it by sGpsXtraInterface to NULL,
+@@ -640,6 +653,44 @@ static jint android_location_GpsLocationProvider_read_sv_status(JNIEnv* env, job
+     return (jint) num_svs;
+ }
+ 
++static jint android_location_GpsLocationProvider_read_gnss_sv_status(JNIEnv* env, jobject obj,
++        jintArray prnArray, jfloatArray snrArray, jfloatArray elevArray, jfloatArray azumArray,
++        jbooleanArray ephemerisPresencesArray,
++        jbooleanArray almanacPresencesArray,
++        jbooleanArray usedInFixArray)
++{
++    // this should only be called from within a call to reportGnssSvStatus
++
++    jint* prns = env->GetIntArrayElements(prnArray, 0);
++    jfloat* snrs = env->GetFloatArrayElements(snrArray, 0);
++    jfloat* elev = env->GetFloatArrayElements(elevArray, 0);
++    jfloat* azim = env->GetFloatArrayElements(azumArray, 0);
++    jboolean* ephemeris_presences = env->GetBooleanArrayElements(ephemerisPresencesArray, 0);
++    jboolean* almanac_presences = env->GetBooleanArrayElements(almanacPresencesArray, 0);
++    jboolean* used_in_fix = env->GetBooleanArrayElements(usedInFixArray, 0);
++
++    int num_svs = sGnssSvStatus.num_svs;
++    for (int i = 0; i < num_svs; i++) {
++        prns[i] = sGnssSvStatus.sv_list[i].prn;
++        snrs[i] = sGnssSvStatus.sv_list[i].snr;
++        elev[i] = sGnssSvStatus.sv_list[i].elevation;
++        azim[i] = sGnssSvStatus.sv_list[i].azimuth;
++
++        ephemeris_presences[i] = sGnssSvStatus.sv_list[i].has_ephemeris ? 1 : 0;
++        almanac_presences[i] = sGnssSvStatus.sv_list[i].has_almanac ? 1 : 0;
++        used_in_fix[i] = sGnssSvStatus.sv_list[i].used_in_fix ? 1 : 0;
++    }
++
++    env->ReleaseIntArrayElements(prnArray, prns, 0);
++    env->ReleaseFloatArrayElements(snrArray, snrs, 0);
++    env->ReleaseFloatArrayElements(elevArray, elev, 0);
++    env->ReleaseFloatArrayElements(azumArray, azim, 0);
++    env->ReleaseBooleanArrayElements(ephemerisPresencesArray, ephemeris_presences, 0);
++    env->ReleaseBooleanArrayElements(almanacPresencesArray, almanac_presences, 0);
++    env->ReleaseBooleanArrayElements(usedInFixArray, used_in_fix, 0);
++    return (jint) num_svs;
++}
++
+ static void android_location_GpsLocationProvider_agps_set_reference_location_cellid(
+         JNIEnv* /* env */, jobject /* obj */, jint type, jint mcc, jint mnc, jint lac, jint cid, jint psc)
+ {
+@@ -1460,6 +1511,9 @@ static JNINativeMethod sMethods[] = {
+     {"native_read_sv_status",
+             "([I[F[F[F[I)I",
+             (void*)android_location_GpsLocationProvider_read_sv_status},
++    {"native_read_gnss_sv_status",
++            "([I[F[F[F[Z[Z[Z)I",
++            (void*)android_location_GpsLocationProvider_read_gnss_sv_status},
+     {"native_read_nmea", "([BI)I", (void*)android_location_GpsLocationProvider_read_nmea},
+     {"native_inject_time", "(JJI)V", (void*)android_location_GpsLocationProvider_inject_time},
+     {"native_inject_location",
diff --git a/6.patch b/6.patch
new file mode 100644
index 0000000..fa07ea7
--- /dev/null
+++ b/6.patch
@@ -0,0 +1,56 @@
+From f379073021f7f0fbb354b0dd7a8955bbf900a94c Mon Sep 17 00:00:00 2001
+From: fire855 <thefire855@gmail.com>
+Date: Sun, 31 Jul 2016 20:20:40 +0200
+Subject: [PATCH] Show carrier name instead of numeric operator Thanks to
+ @DerTeufel
+
+Change-Id: I2ce4349cecfc2b9eda8acb33aeaafdeb43673cb7
+---
+ .../statusbar/policy/MobileSignalController.java       | 18 ++++++++++++++++--
+ 1 file changed, 16 insertions(+), 2 deletions(-)
+
+diff --git a/packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java b/packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java
+index f7d6f85..5e4a420 100644
+--- a/packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java
++++ b/packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java
+@@ -91,6 +91,13 @@ public MobileSignalController(Context context, Config config, boolean hasMobileD
+ 
+         String networkName = info.getCarrierName() != null ? info.getCarrierName().toString()
+                 : mNetworkNameDefault;
++
++        if (isNumeric(networkName)) {
++            String displayName = info.getDisplayName() != null? info.getDisplayName().toString()
++                : mNetworkNameDefault;
++            networkName = displayName;
++        }
++
+         mLastState.networkName = mCurrentState.networkName = networkName;
+         mLastState.networkNameData = mCurrentState.networkNameData = networkName;
+         mLastState.enabled = mCurrentState.enabled = hasMobileData;
+@@ -99,6 +106,13 @@ public MobileSignalController(Context context, Config config, boolean hasMobileD
+         updateDataSim();
+     }
+ 
++    private boolean isNumeric(String str) {
++         for (char c : str.toCharArray()) {
++             if (!Character.isDigit(c)) return false;
++         }
++         return true;
++     }
++
+     public void setConfiguration(Config config) {
+         mConfig = config;
+         mapIconSets();
+@@ -339,10 +353,10 @@ void updateNetworkName(boolean showSpn, String spn, String dataSpn,
+         StringBuilder str = new StringBuilder();
+         StringBuilder strData = new StringBuilder();
+         if (showPlmn && plmn != null) {
+-            str.append(plmn);
++            if (!isNumeric(plmn)) str.append(plmn);
+             strData.append(plmn);
+         }
+-        if (showSpn && spn != null) {
++        if (/*showSpn &&*/ spn != null) {
+             if (str.length() != 0) {
+                 str.append(mNetworkNameSeparator);
+             }
diff --git a/api/current.txt b/api/current.txt
index bfd05f3..84cfa60 100644
--- a/api/current.txt
+++ b/api/current.txt
@@ -16123,6 +16123,7 @@ package android.media {
     method public boolean isPlaying();
     method public void pause() throws java.lang.IllegalStateException;
     method public void prepare() throws java.io.IOException, java.lang.IllegalStateException;
+    method public void prepareWithoutScan() throws java.io.IOException, java.lang.IllegalStateException;
     method public void prepareAsync() throws java.lang.IllegalStateException;
     method public void release();
     method public void reset();
diff --git a/api/system-current.txt b/api/system-current.txt
index 48f6b87..fb8e962 100644
--- a/api/system-current.txt
+++ b/api/system-current.txt
@@ -17390,6 +17390,7 @@ package android.media {
     method public boolean isPlaying();
     method public void pause() throws java.lang.IllegalStateException;
     method public void prepare() throws java.io.IOException, java.lang.IllegalStateException;
+    method public void prepareWithoutScan() throws java.io.IOException, java.lang.IllegalStateException;
     method public void prepareAsync() throws java.lang.IllegalStateException;
     method public void release();
     method public void reset();
diff --git a/core/java/android/hardware/camera2/legacy/PerfMeasurement.java b/core/java/android/hardware/camera2/legacy/PerfMeasurement.java
deleted file mode 100644
index 53278c7..0000000
--- a/core/java/android/hardware/camera2/legacy/PerfMeasurement.java
+++ /dev/null
@@ -1,308 +0,0 @@
-/*
- * Copyright (C) 2014 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package android.hardware.camera2.legacy;
-
-import android.os.SystemClock;
-import android.util.Log;
-
-import java.io.BufferedWriter;
-import java.io.FileWriter;
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.LinkedList;
-import java.util.Queue;
-
-/**
- * GPU and CPU performance measurement for the legacy implementation.
- *
- * <p>Measures CPU and GPU processing duration for a set of operations, and dumps
- * the results into a file.</p>
- *
- * <p>Rough usage:
- * <pre>
- * {@code
- *   <set up workload>
- *   <start long-running workload>
- *   mPerfMeasurement.startTimer();
- *   ...render a frame...
- *   mPerfMeasurement.stopTimer();
- *   <end workload>
- *   mPerfMeasurement.dumpPerformanceData("/sdcard/my_data.txt");
- * }
- * </pre>
- * </p>
- *
- * <p>All calls to this object must be made within the same thread, and the same GL context.
- * PerfMeasurement cannot be used outside of a GL context.  The only exception is
- * dumpPerformanceData, which can be called outside of a valid GL context.</p>
- */
-class PerfMeasurement {
-    private static final String TAG = "PerfMeasurement";
-
-    public static final int DEFAULT_MAX_QUERIES = 3;
-
-    private final long mNativeContext;
-
-    private int mCompletedQueryCount = 0;
-
-    /**
-     * Values for completed measurements
-     */
-    private ArrayList<Long> mCollectedGpuDurations = new ArrayList<>();
-    private ArrayList<Long> mCollectedCpuDurations = new ArrayList<>();
-    private ArrayList<Long> mCollectedTimestamps = new ArrayList<>();
-
-    /**
-     * Values for in-progress measurements (waiting for async GPU results)
-     */
-    private Queue<Long> mTimestampQueue = new LinkedList<>();
-    private Queue<Long> mCpuDurationsQueue = new LinkedList<>();
-
-    private long mStartTimeNs;
-
-    /**
-     * The value returned by {@link #nativeGetNextGlDuration} if no new timing
-     * measurement is available since the last call.
-     */
-    private static final long NO_DURATION_YET = -1l;
-
-    /**
-     * The value returned by {@link #nativeGetNextGlDuration} if timing failed for
-     * the next timing interval
-     */
-    private static final long FAILED_TIMING = -2l;
-
-    /**
-     * Create a performance measurement object with a maximum of {@value #DEFAULT_MAX_QUERIES}
-     * in-progess queries.
-     */
-    public PerfMeasurement() {
-        mNativeContext = nativeCreateContext(DEFAULT_MAX_QUERIES);
-    }
-
-    /**
-     * Create a performance measurement object with maxQueries as the maximum number of
-     * in-progress queries.
-     *
-     * @param maxQueries maximum in-progress queries, must be larger than 0.
-     * @throws IllegalArgumentException if maxQueries is less than 1.
-     */
-    public PerfMeasurement(int maxQueries) {
-        if (maxQueries < 1) throw new IllegalArgumentException("maxQueries is less than 1");
-        mNativeContext = nativeCreateContext(maxQueries);
-    }
-
-    /**
-     * Returns true if the Gl timing methods will work, false otherwise.
-     *
-     * <p>Must be called within a valid GL context.</p>
-     */
-    public static boolean isGlTimingSupported() {
-        return nativeQuerySupport();
-    }
-
-    /**
-     * Dump collected data to file, and clear the stored data.
-     *
-     * <p>
-     * Format is a simple csv-like text file with a header,
-     * followed by a 3-column list of values in nanoseconds:
-     * <pre>
-     *   timestamp gpu_duration cpu_duration
-     *   <long> <long> <long>
-     *   <long> <long> <long>
-     *   <long> <long> <long>
-     *   ....
-     * </pre>
-     * </p>
-     */
-    public void dumpPerformanceData(String path) {
-        try (BufferedWriter dump = new BufferedWriter(new FileWriter(path))) {
-            dump.write("timestamp gpu_duration cpu_duration\n");
-            for (int i = 0; i < mCollectedGpuDurations.size(); i++) {
-                dump.write(String.format("%d %d %d\n",
-                                mCollectedTimestamps.get(i),
-                                mCollectedGpuDurations.get(i),
-                                mCollectedCpuDurations.get(i)));
-            }
-            mCollectedTimestamps.clear();
-            mCollectedGpuDurations.clear();
-            mCollectedCpuDurations.clear();
-        } catch (IOException e) {
-            Log.e(TAG, "Error writing data dump to " + path + ":" + e);
-        }
-    }
-
-    /**
-     * Start a GPU/CPU timing measurement.
-     *
-     * <p>Call before starting a rendering pass. Only one timing measurement can be active at once,
-     * so {@link #stopTimer} must be called before the next call to this method.</p>
-     *
-     * @throws IllegalStateException if the maximum number of queries are in progress already,
-     *                               or the method is called multiple times in a row, or there is
-     *                               a GPU error.
-     */
-    public void startTimer() {
-        nativeStartGlTimer(mNativeContext);
-        mStartTimeNs = SystemClock.elapsedRealtimeNanos();
-    }
-
-    /**
-     * Finish a GPU/CPU timing measurement.
-     *
-     * <p>Call after finishing all the drawing for a rendering pass. Only one timing measurement can
-     * be active at once, so {@link #startTimer} must be called before the next call to this
-     * method.</p>
-     *
-     * @throws IllegalStateException if no GL timer is currently started, or there is a GPU
-     *                               error.
-     */
-    public void stopTimer() {
-        // Complete CPU timing
-        long endTimeNs = SystemClock.elapsedRealtimeNanos();
-        mCpuDurationsQueue.add(endTimeNs - mStartTimeNs);
-        // Complete GL timing
-        nativeStopGlTimer(mNativeContext);
-
-        // Poll to see if GL timing results have arrived; if so
-        // store the results for a frame
-        long duration = getNextGlDuration();
-        if (duration > 0) {
-            mCollectedGpuDurations.add(duration);
-            mCollectedTimestamps.add(mTimestampQueue.isEmpty() ?
-                    NO_DURATION_YET : mTimestampQueue.poll());
-            mCollectedCpuDurations.add(mCpuDurationsQueue.isEmpty() ?
-                    NO_DURATION_YET : mCpuDurationsQueue.poll());
-        }
-        if (duration == FAILED_TIMING) {
-            // Discard timestamp and CPU measurement since GPU measurement failed
-            if (!mTimestampQueue.isEmpty()) {
-                mTimestampQueue.poll();
-            }
-            if (!mCpuDurationsQueue.isEmpty()) {
-                mCpuDurationsQueue.poll();
-            }
-        }
-    }
-
-    /**
-     * Add a timestamp to a timing measurement. These are queued up and matched to completed
-     * workload measurements as they become available.
-     */
-    public void addTimestamp(long timestamp) {
-        mTimestampQueue.add(timestamp);
-    }
-
-    /**
-     * Get the next available GPU timing measurement.
-     *
-     * <p>Since the GPU works asynchronously, the results of a single start/stopGlTimer measurement
-     * will only be available some time after the {@link #stopTimer} call is made. Poll this method
-     * until the result becomes available. If multiple start/endTimer measurements are made in a
-     * row, the results will be available in FIFO order.</p>
-     *
-     * @return The measured duration of the GPU workload for the next pending query, or
-     *         {@link #NO_DURATION_YET} if no queries are pending or the next pending query has not
-     *         yet finished, or {@link #FAILED_TIMING} if the GPU was unable to complete the
-     *         measurement.
-     *
-     * @throws IllegalStateException If there is a GPU error.
-     *
-     */
-    private long getNextGlDuration() {
-        long duration = nativeGetNextGlDuration(mNativeContext);
-        if (duration > 0) {
-            mCompletedQueryCount++;
-        }
-        return duration;
-    }
-
-    /**
-     * Returns the number of measurements so far that returned a valid duration
-     * measurement.
-     */
-    public int getCompletedQueryCount() {
-        return mCompletedQueryCount;
-    }
-
-    @Override
-    protected void finalize() {
-        nativeDeleteContext(mNativeContext);
-    }
-
-    /**
-     * Create a native performance measurement context.
-     *
-     * @param maxQueryCount maximum in-progress queries; must be >= 1.
-     */
-    private static native long nativeCreateContext(int maxQueryCount);
-
-    /**
-     * Delete the native context.
-     *
-     * <p>Not safe to call more than once.</p>
-     */
-    private static native void nativeDeleteContext(long contextHandle);
-
-    /**
-     * Query whether the relevant Gl extensions are available for Gl timing
-     */
-    private static native boolean nativeQuerySupport();
-
-    /**
-     * Start a GL timing section.
-     *
-     * <p>All GL commands between this method and the next {@link #nativeEndGlTimer} will be
-     * included in the timing.</p>
-     *
-     * <p>Must be called from the same thread as calls to {@link #nativeEndGlTimer} and
-     * {@link #nativeGetNextGlDuration}.</p>
-     *
-     * @throws IllegalStateException if a GL error occurs or start is called repeatedly.
-     */
-    protected static native void nativeStartGlTimer(long contextHandle);
-
-    /**
-     * Finish a GL timing section.
-     *
-     * <p>Some time after this call returns, the time the GPU took to
-     * execute all work submitted between the latest {@link #nativeStartGlTimer} and
-     * this call, will become available from calling {@link #nativeGetNextGlDuration}.</p>
-     *
-     * <p>Must be called from the same thread as calls to {@link #nativeStartGlTimer} and
-     * {@link #nativeGetNextGlDuration}.</p>
-     *
-     * @throws IllegalStateException if a GL error occurs or stop is called before start
-     */
-    protected static native void nativeStopGlTimer(long contextHandle);
-
-    /**
-     * Get the next available GL duration measurement, in nanoseconds.
-     *
-     * <p>Must be called from the same thread as calls to {@link #nativeStartGlTimer} and
-     * {@link #nativeEndGlTimer}.</p>
-     *
-     * @return the next GL duration measurement, or {@link #NO_DURATION_YET} if
-     *         no new measurement is available, or {@link #FAILED_TIMING} if timing
-     *         failed for the next duration measurement.
-     * @throws IllegalStateException if a GL error occurs
-     */
-    protected static native long nativeGetNextGlDuration(long contextHandle);
-
-
-}
diff --git a/core/java/android/hardware/camera2/legacy/SurfaceTextureRenderer.java b/core/java/android/hardware/camera2/legacy/SurfaceTextureRenderer.java
index 085b4a6..640adcc 100644
--- a/core/java/android/hardware/camera2/legacy/SurfaceTextureRenderer.java
+++ b/core/java/android/hardware/camera2/legacy/SurfaceTextureRenderer.java
@@ -171,9 +171,6 @@
     private int maPositionHandle;
     private int maTextureHandle;
 
-    private PerfMeasurement mPerfMeasurer = null;
-    private static final String LEGACY_PERF_PROPERTY = "persist.camera.legacy_perf";
-
     public SurfaceTextureRenderer(int facing) {
         mFacing = facing;
 
@@ -501,7 +498,6 @@ private void releaseEGLContext() {
         if (mEGLDisplay != EGL14.EGL_NO_DISPLAY) {
             EGL14.eglMakeCurrent(mEGLDisplay, EGL14.EGL_NO_SURFACE, EGL14.EGL_NO_SURFACE,
                     EGL14.EGL_NO_CONTEXT);
-            dumpGlTiming();
             if (mSurfaces != null) {
                 for (EGLSurfaceHolder holder : mSurfaces) {
                     if (holder.eglSurface != null) {
@@ -553,65 +549,6 @@ private void checkGlError(String msg) {
     }
 
     /**
-     * Save a measurement dump to disk, in
-     * {@code /sdcard/CameraLegacy/durations_<time>_<width1>x<height1>_...txt}
-     */
-    private void dumpGlTiming() {
-        if (mPerfMeasurer == null) return;
-
-        File legacyStorageDir = new File(Environment.getExternalStorageDirectory(), "CameraLegacy");
-        if (!legacyStorageDir.exists()){
-            if (!legacyStorageDir.mkdirs()){
-                Log.e(TAG, "Failed to create directory for data dump");
-                return;
-            }
-        }
-
-        StringBuilder path = new StringBuilder(legacyStorageDir.getPath());
-        path.append(File.separator);
-        path.append("durations_");
-
-        Time now = new Time();
-        now.setToNow();
-        path.append(now.format2445());
-        path.append("_S");
-        for (EGLSurfaceHolder surface : mSurfaces) {
-            path.append(String.format("_%d_%d", surface.width, surface.height));
-        }
-        path.append("_C");
-        for (EGLSurfaceHolder surface : mConversionSurfaces) {
-            path.append(String.format("_%d_%d", surface.width, surface.height));
-        }
-        path.append(".txt");
-        mPerfMeasurer.dumpPerformanceData(path.toString());
-    }
-
-    private void setupGlTiming() {
-        if (PerfMeasurement.isGlTimingSupported()) {
-            Log.d(TAG, "Enabling GL performance measurement");
-            mPerfMeasurer = new PerfMeasurement();
-        } else {
-            Log.d(TAG, "GL performance measurement not supported on this device");
-            mPerfMeasurer = null;
-        }
-    }
-
-    private void beginGlTiming() {
-        if (mPerfMeasurer == null) return;
-        mPerfMeasurer.startTimer();
-    }
-
-    private void addGlTimestamp(long timestamp) {
-        if (mPerfMeasurer == null) return;
-        mPerfMeasurer.addTimestamp(timestamp);
-    }
-
-    private void endGlTiming() {
-        if (mPerfMeasurer == null) return;
-        mPerfMeasurer.stopTimer();
-    }
-
-    /**
      * Return the surface texture to draw to - this is the texture use to when producing output
      * surface buffers.
      *
@@ -669,11 +606,6 @@ public void configureSurfaces(Collection<Pair<Surface, Size>> surfaces) {
                 mConversionSurfaces.get(0).eglSurface);
         initializeGLState();
         mSurfaceTexture = new SurfaceTexture(getTextureId());
-
-        // Set up performance tracking if enabled
-        if (SystemProperties.getBoolean(LEGACY_PERF_PROPERTY, false)) {
-            setupGlTiming();
-        }
     }
 
     /**
@@ -698,10 +630,6 @@ public void drawIntoSurfaces(CaptureCollector targetCollector) {
         boolean doTiming = targetCollector.hasPendingPreviewCaptures();
         checkGlError("before updateTexImage");
 
-        if (doTiming) {
-            beginGlTiming();
-        }
-
         mSurfaceTexture.updateTexImage();
 
         long timestamp = mSurfaceTexture.getTimestamp();
@@ -713,18 +641,12 @@ public void drawIntoSurfaces(CaptureCollector targetCollector) {
             if (DEBUG) {
                 Log.d(TAG, "Dropping preview frame.");
             }
-            if (doTiming) {
-                endGlTiming();
-            }
             return;
         }
 
         RequestHolder request = captureHolder.first;
 
         Collection<Surface> targetSurfaces = request.getHolderTargets();
-        if (doTiming) {
-            addGlTimestamp(timestamp);
-        }
 
         List<Long> targetSurfaceIds = LegacyCameraDevice.getSurfaceIds(targetSurfaces);
         for (EGLSurfaceHolder holder : mSurfaces) {
@@ -769,10 +691,6 @@ public void drawIntoSurfaces(CaptureCollector targetCollector) {
             }
         }
         targetCollector.previewProduced();
-
-        if (doTiming) {
-            endGlTiming();
-        }
     }
 
     /**
diff --git a/core/jni/Android.mk b/core/jni/Android.mk
index d26f1a8..9f38a4e 100644
--- a/core/jni/Android.mk
+++ b/core/jni/Android.mk
@@ -152,7 +152,6 @@ LOCAL_SRC_FILES:= \
     android_hardware_Camera.cpp \
     android_hardware_camera2_CameraMetadata.cpp \
     android_hardware_camera2_legacy_LegacyCameraDevice.cpp \
-    android_hardware_camera2_legacy_PerfMeasurement.cpp \
     android_hardware_camera2_DngCreator.cpp \
     android_hardware_Radio.cpp \
     android_hardware_SensorManager.cpp \
diff --git a/core/jni/AndroidRuntime.cpp b/core/jni/AndroidRuntime.cpp
index a715c5f..4b2c160 100644
--- a/core/jni/AndroidRuntime.cpp
+++ b/core/jni/AndroidRuntime.cpp
@@ -82,7 +82,6 @@ extern int register_android_opengl_jni_GLES31Ext(JNIEnv* env);
 extern int register_android_hardware_Camera(JNIEnv *env);
 extern int register_android_hardware_camera2_CameraMetadata(JNIEnv *env);
 extern int register_android_hardware_camera2_legacy_LegacyCameraDevice(JNIEnv *env);
-extern int register_android_hardware_camera2_legacy_PerfMeasurement(JNIEnv *env);
 extern int register_android_hardware_camera2_DngCreator(JNIEnv *env);
 extern int register_android_hardware_Radio(JNIEnv *env);
 extern int register_android_hardware_SensorManager(JNIEnv *env);
@@ -1392,7 +1391,6 @@ static const RegJNIRec gRegJNI[] = {
     REG_JNI(register_android_hardware_Camera),
     REG_JNI(register_android_hardware_camera2_CameraMetadata),
     REG_JNI(register_android_hardware_camera2_legacy_LegacyCameraDevice),
-    REG_JNI(register_android_hardware_camera2_legacy_PerfMeasurement),
     REG_JNI(register_android_hardware_camera2_DngCreator),
     REG_JNI(register_android_hardware_Radio),
     REG_JNI(register_android_hardware_SensorManager),
diff --git a/core/jni/android_hardware_camera2_legacy_PerfMeasurement.cpp b/core/jni/android_hardware_camera2_legacy_PerfMeasurement.cpp
deleted file mode 100644
index 7257597..0000000
--- a/core/jni/android_hardware_camera2_legacy_PerfMeasurement.cpp
+++ /dev/null
@@ -1,335 +0,0 @@
-/*
- * Copyright (C) 2014 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#define LOG_TAG "Camera2-Legacy-PerfMeasurement-JNI"
-#include <utils/Log.h>
-#include <utils/Errors.h>
-#include <utils/Trace.h>
-#include <utils/Vector.h>
-
-#include "jni.h"
-#include "JNIHelp.h"
-#include "core_jni_helpers.h"
-
-#include <ui/GraphicBuffer.h>
-#include <system/window.h>
-#include <GLES2/gl2.h>
-#include <GLES2/gl2ext.h>
-
-using namespace android;
-
-// fully-qualified class name
-#define PERF_MEASUREMENT_CLASS_NAME "android/hardware/camera2/legacy/PerfMeasurement"
-
-/** GL utility methods copied from com_google_android_gles_jni_GLImpl.cpp */
-
-// Check if the extension at the head of pExtensions is pExtension. Note that pExtensions is
-// terminated by either 0 or space, while pExtension is terminated by 0.
-
-static bool
-extensionEqual(const GLubyte* pExtensions, const GLubyte* pExtension) {
-    while (true) {
-        char a = *pExtensions++;
-        char b = *pExtension++;
-        bool aEnd = a == '\0' || a == ' ';
-        bool bEnd = b == '\0';
-        if (aEnd || bEnd) {
-            return aEnd == bEnd;
-        }
-        if (a != b) {
-            return false;
-        }
-    }
-}
-
-static const GLubyte*
-nextExtension(const GLubyte* pExtensions) {
-    while (true) {
-        char a = *pExtensions++;
-        if (a == '\0') {
-            return pExtensions-1;
-        } else if ( a == ' ') {
-            return pExtensions;
-        }
-    }
-}
-
-static bool
-checkForExtension(const GLubyte* pExtensions, const GLubyte* pExtension) {
-    for (; *pExtensions != '\0'; pExtensions = nextExtension(pExtensions)) {
-        if (extensionEqual(pExtensions, pExtension)) {
-            return true;
-        }
-    }
-    return false;
-}
-
-/** End copied GL utility methods */
-
-bool checkGlError(JNIEnv* env) {
-    int error;
-    if ((error = glGetError()) != GL_NO_ERROR) {
-        jniThrowExceptionFmt(env, "java/lang/IllegalStateException",
-                "GLES20 error: 0x%d", error);
-        return true;
-    }
-    return false;
-}
-
-/**
- * Asynchronous low-overhead GL performance measurement using
- * http://www.khronos.org/registry/gles/extensions/EXT/EXT_disjoint_timer_query.txt
- *
- * Measures the duration of GPU processing for a set of GL commands, delivering
- * the measurement asynchronously once processing completes.
- *
- * All calls must come from a single thread with a valid GL context active.
- **/
-class PerfMeasurementContext {
-  private:
-    Vector<GLuint> mTimingQueries;
-    size_t mTimingStartIndex;
-    size_t mTimingEndIndex;
-    size_t mTimingQueryIndex;
-    size_t mFreeQueries;
-
-    bool mInitDone;
-  public:
-
-    /**
-     * maxQueryCount should be a conservative estimate of how many query objects
-     * will be active at once, which is a function of the GPU's level of
-     * pipelining and the frequency of queries.
-     */
-    PerfMeasurementContext(size_t maxQueryCount):
-            mTimingStartIndex(0),
-            mTimingEndIndex(0),
-            mTimingQueryIndex(0) {
-        mTimingQueries.resize(maxQueryCount);
-        mFreeQueries = maxQueryCount;
-        mInitDone = false;
-    }
-
-    int getMaxQueryCount() {
-        return mTimingQueries.size();
-    }
-
-    /**
-     * Start a measurement period using the next available query object.
-     * Returns INVALID_OPERATION if called multiple times in a row,
-     * and BAD_VALUE if no more query objects are available.
-     */
-    int startGlTimer() {
-        // Lazy init of queries to avoid needing GL context during construction
-        if (!mInitDone) {
-            glGenQueriesEXT(mTimingQueries.size(), mTimingQueries.editArray());
-            mInitDone = true;
-        }
-
-        if (mTimingEndIndex != mTimingStartIndex) {
-            return INVALID_OPERATION;
-        }
-
-        if (mFreeQueries == 0) {
-            return BAD_VALUE;
-        }
-
-        glBeginQueryEXT(GL_TIME_ELAPSED_EXT, mTimingQueries[mTimingStartIndex]);
-
-        mTimingStartIndex = (mTimingStartIndex + 1) % mTimingQueries.size();
-        mFreeQueries--;
-
-        return OK;
-    }
-
-    /**
-     * Finish the current measurement period
-     * Returns INVALID_OPERATION if called before any startGLTimer calls
-     * or if called multiple times in a row.
-     */
-    int stopGlTimer() {
-        size_t nextEndIndex = (mTimingEndIndex + 1) % mTimingQueries.size();
-        if (nextEndIndex != mTimingStartIndex) {
-            return INVALID_OPERATION;
-        }
-        glEndQueryEXT(GL_TIME_ELAPSED_EXT);
-
-        mTimingEndIndex = nextEndIndex;
-
-        return OK;
-    }
-
-    static const nsecs_t NO_DURATION_YET = -1L;
-    static const nsecs_t FAILED_MEASUREMENT = -2L;
-
-    /**
-     * Get the next available duration measurement.
-     *
-     * Returns NO_DURATION_YET if no new measurement is available,
-     * and FAILED_MEASUREMENT if an error occurred during the next
-     * measurement period.
-     *
-     * Otherwise returns a positive number of nanoseconds measuring the
-     * duration of the oldest completed query.
-     */
-    nsecs_t getNextGlDuration() {
-        if (!mInitDone) {
-            // No start/stop called yet
-            return NO_DURATION_YET;
-        }
-
-        GLint available;
-        glGetQueryObjectivEXT(mTimingQueries[mTimingQueryIndex],
-                GL_QUERY_RESULT_AVAILABLE_EXT, &available);
-        if (!available) {
-            return NO_DURATION_YET;
-        }
-
-        GLint64 duration = FAILED_MEASUREMENT;
-        GLint disjointOccurred;
-        glGetIntegerv(GL_GPU_DISJOINT_EXT, &disjointOccurred);
-
-        if (!disjointOccurred) {
-            glGetQueryObjecti64vEXT(mTimingQueries[mTimingQueryIndex],
-                    GL_QUERY_RESULT_EXT,
-                    &duration);
-        }
-
-        mTimingQueryIndex = (mTimingQueryIndex + 1) % mTimingQueries.size();
-        mFreeQueries++;
-
-        return static_cast<nsecs_t>(duration);
-    }
-
-    static bool isMeasurementSupported() {
-        const GLubyte* extensions = glGetString(GL_EXTENSIONS);
-        return checkForExtension(extensions,
-                reinterpret_cast<const GLubyte*>("GL_EXT_disjoint_timer_query"));
-    }
-
-};
-
-PerfMeasurementContext* getContext(jlong context) {
-    return reinterpret_cast<PerfMeasurementContext*>(context);
-}
-
-extern "C" {
-
-static jlong PerfMeasurement_nativeCreateContext(JNIEnv* env, jobject thiz,
-        jint maxQueryCount) {
-    PerfMeasurementContext *context = new PerfMeasurementContext(maxQueryCount);
-    return reinterpret_cast<jlong>(context);
-}
-
-static void PerfMeasurement_nativeDeleteContext(JNIEnv* env, jobject thiz,
-        jlong contextHandle) {
-    PerfMeasurementContext *context = getContext(contextHandle);
-    delete(context);
-}
-
-static jboolean PerfMeasurement_nativeQuerySupport(JNIEnv* env, jobject thiz) {
-    bool supported = PerfMeasurementContext::isMeasurementSupported();
-    checkGlError(env);
-    return static_cast<jboolean>(supported);
-}
-
-static void PerfMeasurement_nativeStartGlTimer(JNIEnv* env, jobject thiz,
-        jlong contextHandle) {
-
-    PerfMeasurementContext *context = getContext(contextHandle);
-    status_t err = context->startGlTimer();
-    if (err != OK) {
-        switch (err) {
-            case INVALID_OPERATION:
-                jniThrowExceptionFmt(env, "java/lang/IllegalStateException",
-                        "Mismatched start/end GL timing calls");
-                return;
-            case BAD_VALUE:
-                jniThrowExceptionFmt(env, "java/lang/IllegalStateException",
-                        "Too many timing queries in progress, max %d",
-                        context->getMaxQueryCount());
-                return;
-            default:
-                jniThrowExceptionFmt(env, "java/lang/IllegalStateException",
-                        "Unknown error starting GL timing");
-                return;
-        }
-    }
-    checkGlError(env);
-}
-
-static void PerfMeasurement_nativeStopGlTimer(JNIEnv* env, jobject thiz,
-            jlong contextHandle) {
-
-    PerfMeasurementContext *context = getContext(contextHandle);
-    status_t err = context->stopGlTimer();
-    if (err != OK) {
-        switch (err) {
-            case INVALID_OPERATION:
-                jniThrowExceptionFmt(env, "java/lang/IllegalStateException",
-                        "Mismatched start/end GL timing calls");
-                return;
-            default:
-                jniThrowExceptionFmt(env, "java/lang/IllegalStateException",
-                        "Unknown error ending GL timing");
-                return;
-        }
-    }
-    checkGlError(env);
-}
-
-static jlong PerfMeasurement_nativeGetNextGlDuration(JNIEnv* env,
-        jobject thiz, jlong contextHandle) {
-    PerfMeasurementContext *context = getContext(contextHandle);
-    nsecs_t duration = context->getNextGlDuration();
-
-    checkGlError(env);
-    return static_cast<jlong>(duration);
-}
-
-} // extern "C"
-
-static JNINativeMethod gPerfMeasurementMethods[] = {
-    { "nativeCreateContext",
-      "(I)J",
-      (jlong *)PerfMeasurement_nativeCreateContext },
-    { "nativeDeleteContext",
-      "(J)V",
-      (void *)PerfMeasurement_nativeDeleteContext },
-    { "nativeQuerySupport",
-      "()Z",
-      (jboolean *)PerfMeasurement_nativeQuerySupport },
-    { "nativeStartGlTimer",
-      "(J)V",
-      (void *)PerfMeasurement_nativeStartGlTimer },
-    { "nativeStopGlTimer",
-      "(J)V",
-      (void *)PerfMeasurement_nativeStopGlTimer },
-    { "nativeGetNextGlDuration",
-      "(J)J",
-      (jlong *)PerfMeasurement_nativeGetNextGlDuration }
-};
-
-
-// Get all the required offsets in java class and register native functions
-int register_android_hardware_camera2_legacy_PerfMeasurement(JNIEnv* env)
-{
-    // Register native functions
-    return RegisterMethodsOrDie(env,
-            PERF_MEASUREMENT_CLASS_NAME,
-            gPerfMeasurementMethods,
-            NELEM(gPerfMeasurementMethods));
-}
diff --git a/libs/hwui/Caches.cpp b/libs/hwui/Caches.cpp
index 2763e89..a324ac37 100644
--- a/libs/hwui/Caches.cpp
+++ b/libs/hwui/Caches.cpp
@@ -87,16 +87,9 @@ void Caches::initFont() {
 }
 
 void Caches::initExtensions() {
-    if (mExtensions.hasDebugMarker()) {
-        eventMark = glInsertEventMarkerEXT;
-
-        startMark = glPushGroupMarkerEXT;
-        endMark = glPopGroupMarkerEXT;
-    } else {
-        eventMark = eventMarkNull;
-        startMark = startMarkNull;
-        endMark = endMarkNull;
-    }
+    eventMark = eventMarkNull;
+    startMark = startMarkNull;
+    endMark = endMarkNull;
 }
 
 void Caches::initConstraints() {
diff --git a/libs/hwui/Properties.cpp b/libs/hwui/Properties.cpp
index 2e63793..413ebece 100644
--- a/libs/hwui/Properties.cpp
+++ b/libs/hwui/Properties.cpp
@@ -29,7 +29,7 @@ bool Properties::debugLayersUpdates = false;
 bool Properties::debugOverdraw = false;
 bool Properties::showDirtyRegions = false;
 bool Properties::skipEmptyFrames = true;
-bool Properties::swapBuffersWithDamage = true;
+bool Properties::swapBuffersWithDamage = false;
 
 DebugLevel Properties::debugLevel = kDebugDisabled;
 OverdrawColorSet Properties::overdrawColorSet = OverdrawColorSet::Default;
diff --git a/libs/hwui/renderthread/EglManager.cpp b/libs/hwui/renderthread/EglManager.cpp
index eb332d5..a2f7106 100644
--- a/libs/hwui/renderthread/EglManager.cpp
+++ b/libs/hwui/renderthread/EglManager.cpp
@@ -261,31 +261,7 @@ bool EglManager::swapBuffers(EGLSurface surface, const SkRect& dirty,
     }
 #endif
 
-#ifdef EGL_KHR_swap_buffers_with_damage
-    if (CC_LIKELY(Properties::swapBuffersWithDamage)) {
-        SkIRect idirty;
-        dirty.roundOut(&idirty);
-        /*
-         * EGL_KHR_swap_buffers_with_damage spec states:
-         *
-         * The rectangles are specified relative to the bottom-left of the surface
-         * and the x and y components of each rectangle specify the bottom-left
-         * position of that rectangle.
-         *
-         * HWUI does everything with 0,0 being top-left, so need to map
-         * the rect
-         */
-        EGLint y = height - (idirty.y() + idirty.height());
-        // layout: {x, y, width, height}
-        EGLint rects[4] = { idirty.x(), y, idirty.width(), idirty.height() };
-        EGLint numrects = dirty.isEmpty() ? 0 : 1;
-        eglSwapBuffersWithDamageKHR(mEglDisplay, surface, rects, numrects);
-    } else {
-        eglSwapBuffers(mEglDisplay, surface);
-    }
-#else
     eglSwapBuffers(mEglDisplay, surface);
-#endif
 
     EGLint err = eglGetError();
     if (CC_LIKELY(err == EGL_SUCCESS)) {
diff --git a/location/java/android/location/GpsStatus.java b/location/java/android/location/GpsStatus.java
index 323f326..cd337b6 100644
--- a/location/java/android/location/GpsStatus.java
+++ b/location/java/android/location/GpsStatus.java
@@ -168,6 +168,41 @@ synchronized void setStatus(int svCount, int[] prns, float[] snrs,
     }
 
     /**
+     * Used internally within {@link LocationManager} to copy GPS status
+     * data from the Location Manager Service to its cached GpsStatus instance.
+     * Is synchronized to ensure that GPS status updates are atomic.
+     *
+     * This is modified to become aware of explicit GNSS support of &gt;32
+     * satellites.
+     */
+    synchronized void setStatusFromGnss(int gnssSvCount, int[] prns, float[] snrs,
+            float[] elevations, float[] azimuths,
+            boolean[] ephemerisPresences,
+            boolean[] almanacPresences,
+            boolean[] usedInFix) {
+        clearSatellites();
+        for (int i = 0; i < gnssSvCount; i++) {
+            int prn = prns[i] - 1;
+
+            if (prn >= 0 && prn < NUM_SATELLITES) {
+                GpsSatellite satellite = mSatellites.get(prn);
+                if (satellite == null) {
+                    satellite = new GpsSatellite(prn);
+                    mSatellites.put(prn, satellite);
+                }
+
+                satellite.mValid = true;
+                satellite.mSnr = snrs[i];
+                satellite.mElevation = elevations[i];
+                satellite.mAzimuth = azimuths[i];
+                satellite.mHasEphemeris = ephemerisPresences[i];
+                satellite.mHasAlmanac = almanacPresences[i];
+                satellite.mUsedInFix = usedInFix[i];
+            }
+        }
+    }
+
+    /**
      * Used by {@link LocationManager#getGpsStatus} to copy LocationManager's
      * cached GpsStatus instance to the client's copy.
      * Since this method is only used within {@link LocationManager#getGpsStatus},
diff --git a/location/java/android/location/IGpsStatusListener.aidl b/location/java/android/location/IGpsStatusListener.aidl
index 62b1c6b..e45199b 100644
--- a/location/java/android/location/IGpsStatusListener.aidl
+++ b/location/java/android/location/IGpsStatusListener.aidl
@@ -26,8 +26,13 @@ oneway interface IGpsStatusListener
     void onGpsStarted();
     void onGpsStopped();
     void onFirstFix(int ttff);
-    void onSvStatusChanged(int svCount, in int[] prns, in float[] snrs, 
-            in float[] elevations, in float[] azimuths, 
+    void onSvStatusChanged(int svCount, in int[] prns, in float[] snrs,
+            in float[] elevations, in float[] azimuths,
             int ephemerisMask, int almanacMask, int usedInFixMask);
+    void onGnssSvStatusChanged(int gnssSvCount, in int[] prns, in float[] snrs,
+            in float[] elevations, in float[] azimuths,
+            in boolean[] ephemerisPresences,
+            in boolean[] almanacPresences,
+            in boolean[] usedInFix);
     void onNmeaReceived(long timestamp, String nmea);
 }
diff --git a/location/java/android/location/LocationManager.java b/location/java/android/location/LocationManager.java
index 4544814..0086434 100644
--- a/location/java/android/location/LocationManager.java
+++ b/location/java/android/location/LocationManager.java
@@ -1479,6 +1479,31 @@ public void onSvStatusChanged(int svCount, int[] prns, float[] snrs,
         }
 
         @Override
+        public void onGnssSvStatusChanged(int gnssSvCount, int[] prns, float[] snrs,
+                float[] elevations, float[] azimuths,
+                boolean[] ephemerisPresences,
+                boolean[] almanacPresences,
+                boolean[] usedInFix) {
+            if (mListener != null) {
+                mGpsStatus.setStatusFromGnss(
+                        gnssSvCount,
+                        prns,
+                        snrs,
+                        elevations,
+                        azimuths,
+                        ephemerisPresences,
+                        almanacPresences,
+                        usedInFix);
+
+                Message msg = Message.obtain();
+                msg.what = GpsStatus.GPS_EVENT_SATELLITE_STATUS;
+                // remove any SV status messages already in the queue
+                mGpsHandler.removeMessages(GpsStatus.GPS_EVENT_SATELLITE_STATUS);
+                mGpsHandler.sendMessage(msg);
+            }
+        }
+
+        @Override
         public void onNmeaReceived(long timestamp, String nmea) {
             if (mNmeaListener != null) {
                 synchronized (mNmeaBuffer) {
diff --git a/media/java/android/media/MediaPlayer.java b/media/java/android/media/MediaPlayer.java
index b3f25ee..3a95717 100644
--- a/media/java/android/media/MediaPlayer.java
+++ b/media/java/android/media/MediaPlayer.java
@@ -1158,6 +1158,9 @@ public void prepare() throws IOException, IllegalStateException {
         _prepare();
         scanInternalSubtitleTracks();
     }
+    public void prepareWithoutScan() throws IOException, IllegalStateException {
+        _prepare();
+    }
 
     private native void _prepare() throws IOException, IllegalStateException;
 
diff --git a/media/jni/android_media_ImageReader.cpp b/media/jni/android_media_ImageReader.cpp
index 0034b07..6c8463c 100644
--- a/media/jni/android_media_ImageReader.cpp
+++ b/media/jni/android_media_ImageReader.cpp
@@ -92,8 +92,8 @@ class JNIImageReaderContext : public ConsumerBase::FrameAvailableListener
     CpuConsumer::LockedBuffer* getLockedBuffer();
     void returnLockedBuffer(CpuConsumer::LockedBuffer* buffer);
 
-    BufferItem* getOpaqueBuffer();
-    void returnOpaqueBuffer(BufferItem* buffer);
+    BufferQueue::BufferItem* getOpaqueBuffer();
+    void returnOpaqueBuffer(BufferQueue::BufferItem* buffer);
 
     void setCpuConsumer(const sp<CpuConsumer>& consumer) { mConsumer = consumer; }
     CpuConsumer* getCpuConsumer() { return mConsumer.get(); }
@@ -123,7 +123,7 @@ class JNIImageReaderContext : public ConsumerBase::FrameAvailableListener
     static void detachJNI();
 
     List<CpuConsumer::LockedBuffer*> mBuffers;
-    List<BufferItem*> mOpaqueBuffers;
+    List<BufferQueue::BufferItem*> mOpaqueBuffers;
     sp<CpuConsumer> mConsumer;
     sp<BufferItemConsumer> mOpaqueConsumer;
     sp<IGraphicBufferProducer> mProducer;
@@ -141,7 +141,7 @@ JNIImageReaderContext::JNIImageReaderContext(JNIEnv* env,
     mClazz((jclass)env->NewGlobalRef(clazz)) {
     for (int i = 0; i < maxImages; i++) {
         CpuConsumer::LockedBuffer *buffer = new CpuConsumer::LockedBuffer;
-        BufferItem* opaqueBuffer = new BufferItem;
+        BufferQueue::BufferItem* opaqueBuffer = new BufferQueue::BufferItem;
         mBuffers.push_back(buffer);
         mOpaqueBuffers.push_back(opaqueBuffer);
     }
@@ -187,18 +187,18 @@ void JNIImageReaderContext::returnLockedBuffer(CpuConsumer::LockedBuffer* buffer
     mBuffers.push_back(buffer);
 }
 
-BufferItem* JNIImageReaderContext::getOpaqueBuffer() {
+BufferQueue::BufferItem* JNIImageReaderContext::getOpaqueBuffer() {
     if (mOpaqueBuffers.empty()) {
         return NULL;
     }
     // Return an opaque buffer pointer and remove it from the list
-    List<BufferItem*>::iterator it = mOpaqueBuffers.begin();
-    BufferItem* buffer = *it;
+    List<BufferQueue::BufferItem*>::iterator it = mOpaqueBuffers.begin();
+    BufferQueue::BufferItem* buffer = *it;
     mOpaqueBuffers.erase(it);
     return buffer;
 }
 
-void JNIImageReaderContext::returnOpaqueBuffer(BufferItem* buffer) {
+void JNIImageReaderContext::returnOpaqueBuffer(BufferQueue::BufferItem* buffer) {
     mOpaqueBuffers.push_back(buffer);
 }
 
@@ -222,7 +222,7 @@ JNIImageReaderContext::~JNIImageReaderContext() {
     }
 
     // Delete opaque buffers
-    for (List<BufferItem *>::iterator it = mOpaqueBuffers.begin();
+    for (List<BufferQueue::BufferItem *>::iterator it = mOpaqueBuffers.begin();
             it != mOpaqueBuffers.end(); it++) {
         delete *it;
     }
@@ -326,7 +326,7 @@ static void Image_setBuffer(JNIEnv* env, jobject thiz,
 }
 
 static void Image_setOpaqueBuffer(JNIEnv* env, jobject thiz,
-        const BufferItem* buffer)
+        const BufferQueue::BufferItem* buffer)
 {
     env->SetLongField(thiz, gSurfaceImageClassInfo.mNativeBuffer, reinterpret_cast<jlong>(buffer));
 }
@@ -716,13 +716,13 @@ static BufferItemConsumer* ImageReader_getOpaqueConsumer(JNIEnv* env, jobject th
     return ctx->getOpaqueConsumer();
 }
 
-static BufferItem* Image_getOpaqueBuffer(JNIEnv* env, jobject image)
+static BufferQueue::BufferItem* Image_getOpaqueBuffer(JNIEnv* env, jobject image)
 {
-    return reinterpret_cast<BufferItem*>(
+    return reinterpret_cast<BufferQueue::BufferItem*>(
             env->GetLongField(image, gSurfaceImageClassInfo.mNativeBuffer));
 }
 
-static int Image_getOpaqueBufferWidth(BufferItem* buffer) {
+static int Image_getOpaqueBufferWidth(BufferQueue::BufferItem* buffer) {
     if (buffer == NULL) return -1;
 
     if (!buffer->mCrop.isEmpty()) {
@@ -731,7 +731,7 @@ static int Image_getOpaqueBufferWidth(BufferItem* buffer) {
     return buffer->mGraphicBuffer->getWidth();
 }
 
-static int Image_getOpaqueBufferHeight(BufferItem* buffer) {
+static int Image_getOpaqueBufferHeight(BufferQueue::BufferItem* buffer) {
     if (buffer == NULL) return -1;
 
     if (!buffer->mCrop.isEmpty()) {
@@ -924,7 +924,7 @@ static void ImageReader_imageRelease(JNIEnv* env, jobject thiz, jobject image)
 
     if (ctx->isOpaque()) {
         BufferItemConsumer* opaqueConsumer = ctx->getOpaqueConsumer();
-        BufferItem* opaqueBuffer = Image_getOpaqueBuffer(env, image);
+        BufferQueue::BufferItem* opaqueBuffer = Image_getOpaqueBuffer(env, image);
         opaqueConsumer->releaseBuffer(*opaqueBuffer); // Not using fence for now.
         Image_setOpaqueBuffer(env, image, NULL);
         ctx->returnOpaqueBuffer(opaqueBuffer);
@@ -951,7 +951,7 @@ static jint ImageReader_opaqueImageSetup(JNIEnv* env, JNIImageReaderContext* ctx
     }
 
     BufferItemConsumer* opaqueConsumer = ctx->getOpaqueConsumer();
-    BufferItem* buffer = ctx->getOpaqueBuffer();
+    BufferQueue::BufferItem* buffer = ctx->getOpaqueBuffer();
     if (buffer == NULL) {
         ALOGW("Unable to acquire a buffer item, very likely client tried to acquire more than"
             " maxImages buffers");
@@ -1106,7 +1106,7 @@ static jint ImageReader_detachImage(JNIEnv* env, jobject thiz, jobject image) {
     }
 
     BufferItemConsumer* opaqueConsumer = ctx->getOpaqueConsumer();
-    BufferItem* opaqueBuffer = Image_getOpaqueBuffer(env, image);
+    BufferQueue::BufferItem* opaqueBuffer = Image_getOpaqueBuffer(env, image);
     if (!opaqueBuffer) {
         ALOGE(
                 "Opaque Image already released and can not be detached from ImageReader!!!");
@@ -1115,7 +1115,7 @@ static jint ImageReader_detachImage(JNIEnv* env, jobject thiz, jobject image) {
         return -1;
     }
 
-    res = opaqueConsumer->detachBuffer(opaqueBuffer->mSlot);
+    res = opaqueConsumer->detachBuffer(opaqueBuffer->mBuf);
     if (res != OK) {
         ALOGE("Opaque Image detach failed: %s (%d)!!!", strerror(-res), res);
         jniThrowRuntimeException(env,
@@ -1214,7 +1214,7 @@ static jobject Image_getByteBuffer(JNIEnv* env, jobject thiz, int idx, int reade
 static jint Image_getWidth(JNIEnv* env, jobject thiz, jint format)
 {
     if (isFormatOpaque(format)) {
-        BufferItem* opaqueBuffer = Image_getOpaqueBuffer(env, thiz);
+        BufferQueue::BufferItem* opaqueBuffer = Image_getOpaqueBuffer(env, thiz);
         return Image_getOpaqueBufferWidth(opaqueBuffer);
     } else {
         CpuConsumer::LockedBuffer* buffer = Image_getLockedBuffer(env, thiz);
@@ -1225,7 +1225,7 @@ static jint Image_getWidth(JNIEnv* env, jobject thiz, jint format)
 static jint Image_getHeight(JNIEnv* env, jobject thiz, jint format)
 {
     if (isFormatOpaque(format)) {
-        BufferItem* opaqueBuffer = Image_getOpaqueBuffer(env, thiz);
+        BufferQueue::BufferItem* opaqueBuffer = Image_getOpaqueBuffer(env, thiz);
         return Image_getOpaqueBufferHeight(opaqueBuffer);
     } else {
         CpuConsumer::LockedBuffer* buffer = Image_getLockedBuffer(env, thiz);
diff --git a/media/jni/android_media_ImageWriter.cpp b/media/jni/android_media_ImageWriter.cpp
index f92a8ef..65f8e84 100644
--- a/media/jni/android_media_ImageWriter.cpp
+++ b/media/jni/android_media_ImageWriter.cpp
@@ -520,7 +520,7 @@ static jint ImageWriter_attachAndQueueImage(JNIEnv* env, jobject thiz, jlong nat
 
     // Image is guaranteed to be from ImageReader at this point, so it is safe to
     // cast to BufferItem pointer.
-    BufferItem* opaqueBuffer = reinterpret_cast<BufferItem*>(nativeBuffer);
+    BufferQueue::BufferItem* opaqueBuffer = reinterpret_cast<BufferQueue::BufferItem*>(nativeBuffer);
     if (opaqueBuffer == NULL) {
         jniThrowException(env, "java/lang/IllegalStateException",
                 "Image is not initialized or already closed");
diff --git a/packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java b/packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java
index 97e9136..5814f9d 100644
--- a/packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java
+++ b/packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java
@@ -90,6 +90,13 @@ public MobileSignalController(Context context, Config config, boolean hasMobileD
 
         String networkName = info.getCarrierName() != null ? info.getCarrierName().toString()
                 : mNetworkNameDefault;
+
+        if (isNumeric(networkName)) {
+            String displayName = info.getDisplayName() != null? info.getDisplayName().toString()
+                : mNetworkNameDefault;
+            networkName = displayName;
+        }
+
         mLastState.networkName = mCurrentState.networkName = networkName;
         mLastState.networkNameData = mCurrentState.networkNameData = networkName;
         mLastState.enabled = mCurrentState.enabled = hasMobileData;
@@ -98,6 +105,13 @@ public MobileSignalController(Context context, Config config, boolean hasMobileD
         updateDataSim();
     }
 
+    private boolean isNumeric(String str) {
+         for (char c : str.toCharArray()) {
+             if (!Character.isDigit(c)) return false;
+         }
+         return true;
+     }
+
     public void setConfiguration(Config config) {
         mConfig = config;
         mapIconSets();
@@ -332,10 +346,10 @@ void updateNetworkName(boolean showSpn, String spn, String dataSpn,
         StringBuilder str = new StringBuilder();
         StringBuilder strData = new StringBuilder();
         if (showPlmn && plmn != null) {
-            str.append(plmn);
+            if (!isNumeric(plmn)) str.append(plmn);
             strData.append(plmn);
         }
-        if (showSpn && spn != null) {
+        if (/*showSpn &&*/ spn != null) {
             if (str.length() != 0) {
                 str.append(mNetworkNameSeparator);
             }
diff --git a/services/core/java/com/android/server/location/GpsLocationProvider.java b/services/core/java/com/android/server/location/GpsLocationProvider.java
index f211108..974c3a1 100644
--- a/services/core/java/com/android/server/location/GpsLocationProvider.java
+++ b/services/core/java/com/android/server/location/GpsLocationProvider.java
@@ -1511,6 +1511,72 @@ private void reportSvStatus() {
     }
 
     /**
+     * Count number of GNSS satellites used in fix.
+     *
+     * We could not rely on Integer.bitCount as GNSS used-in-fix info is not
+     * represented as a bit-mask.
+     */
+    private int countGnssSvUsedInFix(final int gnssSvCount) {
+        int result = 0;
+
+        for (int i = 0; i < gnssSvCount; i++) {
+            if (mSvUsedInFix[i]) {
+                result++;
+            }
+        }
+
+        return result;
+    }
+
+    /**
+     * called from native code to update GNSS SV info
+     */
+    private void reportGnssSvStatus() {
+        final int svCount = native_read_gnss_sv_status(
+                mSvs,
+                mSnrs,
+                mSvElevations,
+                mSvAzimuths,
+                mSvEphemerisPresences,
+                mSvAlmanacPresences,
+                mSvUsedInFix);
+        mListenerHelper.onGnssSvStatusChanged(
+                svCount,
+                mSvs,
+                mSnrs,
+                mSvElevations,
+                mSvAzimuths,
+                mSvEphemerisPresences,
+                mSvAlmanacPresences,
+                mSvUsedInFix);
+
+        if (VERBOSE) {
+            Log.v(TAG, "GNSS SV count: " + svCount);
+            for (int i = 0; i < svCount; i++) {
+                Log.v(TAG, "sv: " + mSvs[i] +
+                        " snr: " + mSnrs[i]/10 +
+                        " elev: " + mSvElevations[i] +
+                        " azimuth: " + mSvAzimuths[i] +
+                        (!mSvEphemerisPresences[i] ? "  " : " E") +
+                        (!mSvAlmanacPresences[i] ? "  " : " A") +
+                        (!mSvUsedInFix[i] ? "" : "U"));
+            }
+        }
+
+        // return number of sets used in fix instead of total
+        updateStatus(mStatus, countGnssSvUsedInFix(svCount));
+
+        if (mNavigating && mStatus == LocationProvider.AVAILABLE && mLastFixTime > 0 &&
+            System.currentTimeMillis() - mLastFixTime > RECENT_FIX_TIMEOUT) {
+            // send an intent to notify that the GPS is no longer receiving fixes.
+            Intent intent = new Intent(LocationManager.GPS_FIX_CHANGE_ACTION);
+            intent.putExtra(LocationManager.EXTRA_GPS_ENABLED, false);
+            mContext.sendBroadcastAsUser(intent, UserHandle.ALL);
+            updateStatus(LocationProvider.TEMPORARILY_UNAVAILABLE, mSvCount);
+        }
+    }
+
+    /**
      * called from native code to update AGPS status
      */
     private void reportAGpsStatus(int type, int status, byte[] ipaddr) {
@@ -2243,12 +2309,18 @@ public void reset() {
     private static final int ALMANAC_MASK = 1;
     private static final int USED_FOR_FIX_MASK = 2;
 
+    // GNSS extension
+    private static final int MAX_GNSS_SVS = 256;
+
     // preallocated arrays, to avoid memory allocation in reportStatus()
-    private int mSvs[] = new int[MAX_SVS];
-    private float mSnrs[] = new float[MAX_SVS];
-    private float mSvElevations[] = new float[MAX_SVS];
-    private float mSvAzimuths[] = new float[MAX_SVS];
+    private int mSvs[] = new int[MAX_GNSS_SVS];
+    private float mSnrs[] = new float[MAX_GNSS_SVS];
+    private float mSvElevations[] = new float[MAX_GNSS_SVS];
+    private float mSvAzimuths[] = new float[MAX_GNSS_SVS];
     private int mSvMasks[] = new int[3];
+    private boolean mSvEphemerisPresences[] = new boolean[MAX_GNSS_SVS];
+    private boolean mSvAlmanacPresences[] = new boolean[MAX_GNSS_SVS];
+    private boolean mSvUsedInFix[] = new boolean[MAX_GNSS_SVS];
     private int mSvCount;
     // preallocated to avoid memory allocation in reportNmea()
     private byte[] mNmeaBuffer = new byte[120];
@@ -2270,6 +2342,12 @@ private native boolean native_set_position_mode(int mode, int recurrence, int mi
     // mask[0] is ephemeris mask and mask[1] is almanac mask
     private native int native_read_sv_status(int[] svs, float[] snrs,
             float[] elevations, float[] azimuths, int[] masks);
+    // returns number of GNSS SVs
+    private native int native_read_gnss_sv_status(int[] svs, float[] snrs,
+            float[] elevations, float[] azimuths,
+            boolean[] ephemerisPresences,
+            boolean[] almanacPresences,
+            boolean[] usedInFix);
     private native int native_read_nmea(byte[] buffer, int bufferSize);
     private native void native_inject_location(double latitude, double longitude, float accuracy);
 
@@ -2321,4 +2399,3 @@ private static native boolean native_add_geofence(int geofenceId, double latitud
     // GNSS Configuration
     private static native void native_configuration_update(String configData);
 }
-
diff --git a/services/core/java/com/android/server/location/GpsStatusListenerHelper.java b/services/core/java/com/android/server/location/GpsStatusListenerHelper.java
index 53ff6c2..c49eda0 100644
--- a/services/core/java/com/android/server/location/GpsStatusListenerHelper.java
+++ b/services/core/java/com/android/server/location/GpsStatusListenerHelper.java
@@ -98,6 +98,32 @@ public void execute(IGpsStatusListener listener) throws RemoteException {
         foreach(operation);
     }
 
+    public void onGnssSvStatusChanged(
+            final int svCount,
+            final int[] prns,
+            final float[] snrs,
+            final float[] elevations,
+            final float[] azimuths,
+            final boolean[] ephemerisPresences,
+            final boolean[] almanacPresences,
+            final boolean[] usedInFix) {
+        Operation operation = new Operation() {
+            @Override
+            public void execute(IGpsStatusListener listener) throws RemoteException {
+                listener.onGnssSvStatusChanged(
+                        svCount,
+                        prns,
+                        snrs,
+                        elevations,
+                        azimuths,
+                        ephemerisPresences,
+                        almanacPresences,
+                        usedInFix);
+            }
+        };
+        foreach(operation);
+    }
+
     public void onNmeaReceived(final long timestamp, final String nmea) {
         Operation operation = new Operation() {
             @Override
diff --git a/services/core/jni/com_android_server_location_GpsLocationProvider.cpp b/services/core/jni/com_android_server_location_GpsLocationProvider.cpp
index 5c27b1f..fee3a22 100644
--- a/services/core/jni/com_android_server_location_GpsLocationProvider.cpp
+++ b/services/core/jni/com_android_server_location_GpsLocationProvider.cpp
@@ -21,7 +21,7 @@
 #include "JNIHelp.h"
 #include "jni.h"
 #include "hardware/hardware.h"
-#include "hardware/gps.h"
+#include "hardware/gps_mtk.h"
 #include "hardware_legacy/power.h"
 #include "utils/Log.h"
 #include "utils/misc.h"
@@ -39,6 +39,7 @@ static jobject mCallbacksObj = NULL;
 static jmethodID method_reportLocation;
 static jmethodID method_reportStatus;
 static jmethodID method_reportSvStatus;
+static jmethodID method_reportGnssSvStatus;
 static jmethodID method_reportAGpsStatus;
 static jmethodID method_reportNmea;
 static jmethodID method_setEngineCapabilities;
@@ -69,6 +70,7 @@ static const GnssConfigurationInterface* sGnssConfigurationInterface = NULL;
 
 // temporary storage for GPS callbacks
 static GpsSvStatus  sGpsSvStatus;
+static GnssSvStatus  sGnssSvStatus;
 static const char* sNmeaString;
 static int sNmeaStringLength;
 
@@ -110,6 +112,14 @@ static void sv_status_callback(GpsSvStatus* sv_status)
     checkAndClearExceptionFromCallback(env, __FUNCTION__);
 }
 
+static void gnss_sv_status_callback(GnssSvStatus* sv_status)
+{
+    JNIEnv* env = AndroidRuntime::getJNIEnv();
+    memcpy(&sGnssSvStatus, sv_status, sizeof(sGnssSvStatus));
+    env->CallVoidMethod(mCallbacksObj, method_reportGnssSvStatus);
+    checkAndClearExceptionFromCallback(env, __FUNCTION__);
+}
+
 static void nmea_callback(GpsUtcTime timestamp, const char* nmea, int length)
 {
     JNIEnv* env = AndroidRuntime::getJNIEnv();
@@ -151,8 +161,8 @@ static pthread_t create_thread_callback(const char* name, void (*start)(void *),
     return (pthread_t)AndroidRuntime::createJavaThread(name, start, arg);
 }
 
-GpsCallbacks sGpsCallbacks = {
-    sizeof(GpsCallbacks),
+GpsCallbacks_mtk sGpsCallbacks = {
+    sizeof(GpsCallbacks_mtk),
     location_callback,
     status_callback,
     sv_status_callback,
@@ -162,6 +172,8 @@ GpsCallbacks sGpsCallbacks = {
     release_wakelock_callback,
     create_thread_callback,
     request_utc_time_callback,
+    // MTK
+    gnss_sv_status_callback,
 };
 
 static void xtra_download_request_callback()
@@ -446,6 +458,7 @@ static void android_location_GpsLocationProvider_class_init_native(JNIEnv* env,
     method_reportLocation = env->GetMethodID(clazz, "reportLocation", "(IDDDFFFJ)V");
     method_reportStatus = env->GetMethodID(clazz, "reportStatus", "(I)V");
     method_reportSvStatus = env->GetMethodID(clazz, "reportSvStatus", "()V");
+    method_reportGnssSvStatus = env->GetMethodID(clazz, "reportGnssSvStatus", "()V");
     method_reportAGpsStatus = env->GetMethodID(clazz, "reportAGpsStatus", "(II[B)V");
     method_reportNmea = env->GetMethodID(clazz, "reportNmea", "(J)V");
     method_setEngineCapabilities = env->GetMethodID(clazz, "setEngineCapabilities", "(I)V");
@@ -534,7 +547,7 @@ static jboolean android_location_GpsLocationProvider_init(JNIEnv* env, jobject o
         mCallbacksObj = env->NewGlobalRef(obj);
 
     // fail if the main interface fails to initialize
-    if (!sGpsInterface || sGpsInterface->init(&sGpsCallbacks) != 0)
+    if (!sGpsInterface || sGpsInterface->init((GpsCallbacks*)&sGpsCallbacks) != 0)
         return JNI_FALSE;
 
     // if XTRA initialization fails we will disable it by sGpsXtraInterface to NULL,
@@ -640,6 +653,44 @@ static jint android_location_GpsLocationProvider_read_sv_status(JNIEnv* env, job
     return (jint) num_svs;
 }
 
+static jint android_location_GpsLocationProvider_read_gnss_sv_status(JNIEnv* env, jobject obj,
+        jintArray prnArray, jfloatArray snrArray, jfloatArray elevArray, jfloatArray azumArray,
+        jbooleanArray ephemerisPresencesArray,
+        jbooleanArray almanacPresencesArray,
+        jbooleanArray usedInFixArray)
+{
+    // this should only be called from within a call to reportGnssSvStatus
+
+    jint* prns = env->GetIntArrayElements(prnArray, 0);
+    jfloat* snrs = env->GetFloatArrayElements(snrArray, 0);
+    jfloat* elev = env->GetFloatArrayElements(elevArray, 0);
+    jfloat* azim = env->GetFloatArrayElements(azumArray, 0);
+    jboolean* ephemeris_presences = env->GetBooleanArrayElements(ephemerisPresencesArray, 0);
+    jboolean* almanac_presences = env->GetBooleanArrayElements(almanacPresencesArray, 0);
+    jboolean* used_in_fix = env->GetBooleanArrayElements(usedInFixArray, 0);
+
+    int num_svs = sGnssSvStatus.num_svs;
+    for (int i = 0; i < num_svs; i++) {
+        prns[i] = sGnssSvStatus.sv_list[i].prn;
+        snrs[i] = sGnssSvStatus.sv_list[i].snr;
+        elev[i] = sGnssSvStatus.sv_list[i].elevation;
+        azim[i] = sGnssSvStatus.sv_list[i].azimuth;
+
+        ephemeris_presences[i] = sGnssSvStatus.sv_list[i].has_ephemeris ? 1 : 0;
+        almanac_presences[i] = sGnssSvStatus.sv_list[i].has_almanac ? 1 : 0;
+        used_in_fix[i] = sGnssSvStatus.sv_list[i].used_in_fix ? 1 : 0;
+    }
+
+    env->ReleaseIntArrayElements(prnArray, prns, 0);
+    env->ReleaseFloatArrayElements(snrArray, snrs, 0);
+    env->ReleaseFloatArrayElements(elevArray, elev, 0);
+    env->ReleaseFloatArrayElements(azumArray, azim, 0);
+    env->ReleaseBooleanArrayElements(ephemerisPresencesArray, ephemeris_presences, 0);
+    env->ReleaseBooleanArrayElements(almanacPresencesArray, almanac_presences, 0);
+    env->ReleaseBooleanArrayElements(usedInFixArray, used_in_fix, 0);
+    return (jint) num_svs;
+}
+
 static void android_location_GpsLocationProvider_agps_set_reference_location_cellid(
         JNIEnv* /* env */, jobject /* obj */, jint type, jint mcc, jint mnc, jint lac, jint cid)
 {
@@ -1455,6 +1506,9 @@ static JNINativeMethod sMethods[] = {
     {"native_read_sv_status",
             "([I[F[F[F[I)I",
             (void*)android_location_GpsLocationProvider_read_sv_status},
+    {"native_read_gnss_sv_status",
+            "([I[F[F[F[Z[Z[Z)I",
+            (void*)android_location_GpsLocationProvider_read_gnss_sv_status},
     {"native_read_nmea", "([BI)I", (void*)android_location_GpsLocationProvider_read_nmea},
     {"native_inject_time", "(JJI)V", (void*)android_location_GpsLocationProvider_inject_time},
     {"native_inject_location",